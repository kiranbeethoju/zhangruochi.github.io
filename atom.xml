<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RUOCHI.AI</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhangruochi.com/"/>
  <updated>2019-12-07T03:43:28.720Z</updated>
  <id>https://zhangruochi.com/</id>
  
  <author>
    <name>Ruochi Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Computational Graph</title>
    <link href="https://zhangruochi.com/Computational-Graph/2019/12/06/"/>
    <id>https://zhangruochi.com/Computational-Graph/2019/12/06/</id>
    <published>2019-12-07T01:21:51.000Z</published>
    <updated>2019-12-07T03:43:28.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="General-Computation-Graph"><a href="#General-Computation-Graph" class="headerlink" title="General Computation Graph"></a>General Computation Graph</h2><ol><li>Fprop: visit nodes in <strong>topological sort</strong> order<ul><li>Compute value of node given predecessors</li></ul></li><li>Bprop:<ul><li>initialize output gradient = 1 </li><li>visit nodes in reverse order:<ul><li>Compute gradient wrt each node using gradient wrt successors<script type="math/tex; mode=display">{y_1,y_2, \cdots, y_n} = successors of x</script><script type="math/tex; mode=display">\frac{\partial z}{\partial x} = \sum_{i=1}^{n}\frac{\partial z}{\partial y_i}\frac{\partial y_i}{\partial x}</script>Done correctly, big O() complexity of fprop and bprop is the same</li></ul></li></ul></li></ol><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="1.png" width="50%" height="50%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">picture from lecture note of cs224n</div></center><h2 id="Automatic-Differentiation"><a href="#Automatic-Differentiation" class="headerlink" title="Automatic Differentiation"></a>Automatic Differentiation</h2><ul><li>The gradient computation canbe automatically inferred from the symbolic expression of the fprop</li><li>Each node type needs to know how to compute its output and how to compute the gradient wrt its inputs given the gradient wrt its output</li><li>Modern DL frameworks(Tensorflow, PyTorch, etc.) do backpropagation for you but mainly leave layer/node writer to hand-calculate the local derivative</li></ul><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="2.png" width="50%" height="50%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">picture from lecture note of cs224n</div></center><h2 id="Example-Sigmoid"><a href="#Example-Sigmoid" class="headerlink" title="Example: Sigmoid"></a>Example: Sigmoid</h2><p>The gates we introduced above are relatively arbitrary. Any kind of <strong>differentiable function</strong> can act as a gate, and we can group multiple gates into a single gate, or decompose a function into multiple gates whenever it is convenient. Lets look at another expression that illustrates this point:</p><script type="math/tex; mode=display">f(w,x) = \frac{1}{1+e^{-(w_0x_0 + w_1x_1 + w_2)}}</script><p>We have the knowlege of derivatives</p><script type="math/tex; mode=display">\begin{aligned}f(x) = \frac{1}{x} \hspace{1in} & \rightarrow \hspace{1in} \frac{df}{dx} = -1/x^2 \\f_c(x) = c + x\hspace{1in}  & \rightarrow  \hspace{1in} \frac{df}{dx} = 1 \\f(x) = e^x\hspace{1in}  & \rightarrow  \hspace{1in} \frac{df}{dx} = e^x \\f_a(x) = ax\hspace{1in} & \rightarrow  \hspace{1in} \frac{df}{dx} = a \\\end{aligned}</script><p>the picture blow shows the visual representation of the computation. The forward pass computes values from inputs to output (shown in green). The backward pass then performs backpropagation which starts at the end and recursively applies the chain rule to compute the gradients (shown in red) all the way to the inputs of the circuit. The gradients can be thought of as flowing backwards through the circuit.</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="4.png" width="80%" height="80%">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">picture from lecture note of cs231n</div></center><p>It turns out that the derivative of the sigmoid function with respect to its input simplifies if you perform the derivation (after a fun tricky part where we add and subtract a 1 in the numerator):</p><script type="math/tex; mode=display">\sigma(x) = \frac{1}{1+e^{-x}} \\\\\rightarrow \hspace{0.3in} \frac{d\sigma(x)}{dx} = \frac{e^{-x}}{(1+e^{-x})^2} = \left( \frac{1 + e^{-x} - 1}{1 + e^{-x}} \right) \left( \frac{1}{1+e^{-x}} \right) = \left( 1 - \sigma(x) \right) \sigma(x)</script><p>As we see, the gradient turns out to simplify and becomes surprisingly simple. For example, the sigmoid expression receives the input 1.0 and computes the output 0.73 during the forward pass. The derivation above shows that the local gradient would simply be (1 - 0.73) * 0.73 = 0.2, as the circuit computed before (see the image above), except this way it would be done with a single, simple and efficient expression (and with less numerical issues). Therefore, in any real practical application it would be very useful to group these operations into a single gate. Lets see the backprop for this neuron in code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">w = [<span class="number">2</span>,<span class="number">-3</span>,<span class="number">-3</span>] <span class="comment"># assume some random weights and data</span></span><br><span class="line">x = [<span class="number">-1</span>, <span class="number">-2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># forward pass</span></span><br><span class="line">dot = w[<span class="number">0</span>]*x[<span class="number">0</span>] + w[<span class="number">1</span>]*x[<span class="number">1</span>] + w[<span class="number">2</span>]</span><br><span class="line">f = <span class="number">1.0</span> / (<span class="number">1</span> + math.exp(-dot)) <span class="comment"># sigmoid function</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># backward pass through the neuron (backpropagation)</span></span><br><span class="line">ddot = (<span class="number">1</span> - f) * f <span class="comment"># gradient on dot variable, using the sigmoid gradient derivation</span></span><br><span class="line">dx = [w[<span class="number">0</span>] * ddot, w[<span class="number">1</span>] * ddot] <span class="comment"># backprop into x</span></span><br><span class="line">dw = [x[<span class="number">0</span>] * ddot, x[<span class="number">1</span>] * ddot, <span class="number">1.0</span> * ddot] <span class="comment"># backprop into w</span></span><br><span class="line"><span class="comment"># we're done! we have the gradients on the inputs to the circuit</span></span><br></pre></td></tr></table></figure><h2 id="Staged-computation"><a href="#Staged-computation" class="headerlink" title="Staged computation"></a>Staged computation</h2><p>Lets see this with another example. Suppose that we have a function of the form:</p><script type="math/tex; mode=display">f(x,y) = \frac{x + \sigma(y)}{\sigma(x) + (x+y)^2}</script><p>We don’t need to have an explicit function written down that evaluates the gradient. We only have to know how to compute it. Here is how we would structure the <strong>forward pass</strong> of such expression:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">3</span> <span class="comment"># example values</span></span><br><span class="line">y = <span class="number">-4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># forward pass</span></span><br><span class="line">sigy = <span class="number">1.0</span> / (<span class="number">1</span> + math.exp(-y)) <span class="comment"># sigmoid in numerator   #(1)</span></span><br><span class="line">num = x + sigy <span class="comment"># numerator                               #(2)</span></span><br><span class="line">sigx = <span class="number">1.0</span> / (<span class="number">1</span> + math.exp(-x)) <span class="comment"># sigmoid in denominator #(3)</span></span><br><span class="line">xpy = x + y                                              <span class="comment">#(4)</span></span><br><span class="line">xpysqr = xpy**<span class="number">2</span>                                          <span class="comment">#(5)</span></span><br><span class="line">den = sigx + xpysqr <span class="comment"># denominator                        #(6)</span></span><br><span class="line">invden = <span class="number">1.0</span> / den                                       <span class="comment">#(7)</span></span><br><span class="line">f = num * invden <span class="comment"># done!                                 #(8)</span></span><br></pre></td></tr></table></figure><p>Computing the backprop pass is easy: We’ll go backwards and for every variable along the way in the forward pass (sigy, num, sigx, xpy, xpysqr, den, invden) we will have the same variable, but one that begins with a <code>d</code>, which will hold the gradient of the output of the circuit with respect to that variable.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># backprop f = num * invden</span></span><br><span class="line">dnum = invden <span class="comment"># gradient on numerator                             #(8)</span></span><br><span class="line">dinvden = num                                                     <span class="comment">#(8)</span></span><br><span class="line"><span class="comment"># backprop invden = 1.0 / den </span></span><br><span class="line">dden = (<span class="number">-1.0</span> / (den**<span class="number">2</span>)) * dinvden                                <span class="comment">#(7)</span></span><br><span class="line"><span class="comment"># backprop den = sigx + xpysqr</span></span><br><span class="line">dsigx = (<span class="number">1</span>) * dden                                                <span class="comment">#(6)</span></span><br><span class="line">dxpysqr = (<span class="number">1</span>) * dden                                              <span class="comment">#(6)</span></span><br><span class="line"><span class="comment"># backprop xpysqr = xpy**2</span></span><br><span class="line">dxpy = (<span class="number">2</span> * xpy) * dxpysqr                                        <span class="comment">#(5)</span></span><br><span class="line"><span class="comment"># backprop xpy = x + y</span></span><br><span class="line">dx = (<span class="number">1</span>) * dxpy                                                   <span class="comment">#(4)</span></span><br><span class="line">dy = (<span class="number">1</span>) * dxpy                                                   <span class="comment">#(4)</span></span><br><span class="line"><span class="comment"># backprop sigx = 1.0 / (1 + math.exp(-x))</span></span><br><span class="line">dx += ((<span class="number">1</span> - sigx) * sigx) * dsigx <span class="comment"># Notice += !! See notes below  #(3)</span></span><br><span class="line"><span class="comment"># backprop num = x + sigy</span></span><br><span class="line">dx += (<span class="number">1</span>) * dnum                                                  <span class="comment">#(2)</span></span><br><span class="line">dsigy = (<span class="number">1</span>) * dnum                                                <span class="comment">#(2)</span></span><br><span class="line"><span class="comment"># backprop sigy = 1.0 / (1 + math.exp(-y))</span></span><br><span class="line">dy += ((<span class="number">1</span> - sigy) * sigy) * dsigy                                 <span class="comment">#(1)</span></span><br><span class="line"><span class="comment"># done! phew</span></span><br></pre></td></tr></table></figure><h2 id="Patterns"><a href="#Patterns" class="headerlink" title="Patterns"></a>Patterns</h2><ol><li><strong>add distributes the upstream gradient</strong>: The add gate always takes the gradient on its output and distributes it equally to all of its inputs, regardless of what their values were during the forward pass. This follows from the fact that the local gradient for the add operation is simply +1.0, so the gradients on all inputs will exactly equal the gradients on the output because it will be multiplied by x1.0 (and remain unchanged).</li><li><strong>max “routes” the upstream gradient</strong>: The max gate routes the gradient. Unlike the add gate which distributed the gradient unchanged to all its inputs, the max gate distributes the gradient (unchanged) to exactly one of its inputs (the input that had the highest value during the forward pass). This is because the local gradient for a max gate is 1.0 for the highest value, and 0.0 for all other values.</li><li><strong>mul switches the upstream gradient</strong>: The multiply gate is a little less easy to interpret. Its local gradients are the input values (except switched), and this is multiplied by the gradient on its output during the chain rule. </li></ol><h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="3.png" width="30%" height="30%">    <br><!--     <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;"></div> --></center><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiplyGate</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x,y)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">        z = x*y</span><br><span class="line">        <span class="keyword">return</span> z</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span><span class="params">(dz)</span>:</span></span><br><span class="line">        dx = self.y * dz <span class="comment"># [dz/dz * dL/dz]</span></span><br><span class="line">        dy = self.x * dz <span class="comment"># [dz/dy * dL/dz]</span></span><br><span class="line">        <span class="keyword">return</span> [dx,dy]</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li>lecture notes and slides from <a href="http://cs231n.github.io/optimization-2/" target="_blank" rel="noopener">http://cs231n.github.io/optimization-2/</a></li><li>lecture notes and slides from <a href="http://web.stanford.edu/class/cs224n/" target="_blank" rel="noopener">http://web.stanford.edu/class/cs224n/</a></li></ol>]]></content>
    
    <summary type="html">
    
      What is computational graph, how to use computationl graph ?
    
    </summary>
    
    
      <category term="Artificial Intelligence" scheme="https://zhangruochi.com/categories/Artificial-Intelligence/"/>
    
      <category term="Deep Learning" scheme="https://zhangruochi.com/categories/Artificial-Intelligence/Deep-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>Word Vectors</title>
    <link href="https://zhangruochi.com/Word-Vectors/2019/12/04/"/>
    <id>https://zhangruochi.com/Word-Vectors/2019/12/04/</id>
    <published>2019-12-04T21:14:11.000Z</published>
    <updated>2019-12-05T01:28:28.126Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Why-we-need-Word-Vectors"><a href="#Why-we-need-Word-Vectors" class="headerlink" title="Why we need Word Vectors ?"></a>Why we need Word Vectors ?</h2><p>We want to encode word tokens each into some vector that represents a point in some sort of “word” space. This is paramount for a number of reasons but the most intuitive reason is that perhaps there actually exists some N-dimensional space (such that N &lt;&lt; 13 million) that is sufficient to encode all semantics of our language. Each dimension would encode some meaning that we transfer using speech. For instance, semantic dimensions might indicate tense (past vs. present vs. future), count (singular vs. plural), and gender (masculine vs. feminine).</p><h2 id="One-hot-vector"><a href="#One-hot-vector" class="headerlink" title="One-hot vector"></a>One-hot vector</h2><p>Represent every word as an $\mathbb{R}^{|v|\cdot 1}$ vector with all 0s and one 1 at the index of that word in the sorted english language. $|V|$ is the size of our vocabulary. Word vectors in this type of encoding would appear as the following:</p><script type="math/tex; mode=display">W^{abandon} = \begin{bmatrix} 1 \\0 \\0 \\0 \\\vdots \\0 \\\end{bmatrix}</script><p>We represent each word as a completely independent entity. This word representation <strong>does not</strong> give us directly any notion of similarity. For instance,</p><script type="math/tex; mode=display">(W^{hotel})^{T}W^{motel} =(W^{hotel})^{T}W^{cat} = 0</script><h2 id="SVD-Based-Methods"><a href="#SVD-Based-Methods" class="headerlink" title="SVD Based Methods"></a>SVD Based Methods</h2><p>For this class of methods to find word embeddings (otherwise known as word vectors), we first loop over a massive dataset and accumulate word co-occurrence counts in some form of a matrix X, and then perform Singular Value Decomposition on X to get a<br>$USV^{T}$ decomposition. We then use the rows of U as the word embeddings for all words in our dictionary. Let us discuss a few choices of X.</p><h3 id="Word-Document-Matrix"><a href="#Word-Document-Matrix" class="headerlink" title="Word-Document Matrix"></a>Word-Document Matrix</h3><p>As our first attempt, we make the bold conjecture that words thatare related will often appear in the <strong>same documents</strong>. We use this fact to build a word-document matrix, $X$ in the following manner: Loop over billions of documents and for each time word $i$ appears in document $j$, we add one to entry $X_{ij}$. This is obviously a very large matrix $\mathbb{R}^{|v|\cdot M}$ and it scales with the number of documents (M). So perhaps we can try something better.</p><h3 id="Window-based-Co-occurrence-Matrix"><a href="#Window-based-Co-occurrence-Matrix" class="headerlink" title="Window based Co-occurrence Matrix"></a>Window based Co-occurrence Matrix</h3><p>A co-occurrence matrix counts how often things co-occur in some environment. Given some word $w_i$ occurring in the document, we consider the <em>context window</em> surrounding $w_i$. Supposing our fixed window size is $n$, then this is the $n$ preceding and $n$ subsequent words in that document, i.e. words $w_{i-n} \dots w_{i-1}$ and $w_{i+1} \dots w_{i+n}$. We build a <em>co-occurrence matrix</em> $M$, which is a symmetric word-by-word matrix in which $M_{ij}$ is the number of times $w_j$ appears inside $w_i$’s window.</p><p><strong>Example: Co-Occurrence with Fixed Window of n=1</strong>:</p><ul><li>Document 1: “all that glitters is not gold”</li><li>Document 2: “all is well that ends well”</li></ul><div class="table-container"><table><thead><tr><th>*</th><th>START</th><th>all</th><th>that</th><th>glitters</th><th>is</th><th>not</th><th>gold</th><th>well</th><th>ends</th><th>END</th></tr></thead><tbody><tr><td>START</td><td>0</td><td>2</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>all</td><td>2</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>that</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>glitters</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>is</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>not</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>gold</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>well</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>ends</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>END</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td></tr></tbody></table></div><p><strong>Note:</strong> In NLP, we often add START and END tokens to represent the beginning and end of sentences, paragraphs or documents. In thise case we imagine START and END tokens encapsulating each document, e.g., “START All that glitters is not gold END”, and include these tokens in our co-occurrence counts.</p><p>The rows (or columns) of this matrix provide one type of word vectors (those based on word-word co-occurrence), but the vectors will be large in general (linear in the number of distinct words in a corpus). Thus, our next step is to run <em>dimensionality reduction</em>. In particular, we will run <em>SVD (Singular Value Decomposition)</em>, which is a kind of generalized <em>PCA (Principal Components Analysis)</em> to select the top $k$ principal components. Here’s a visualization of dimensionality reduction with SVD. In this picture our co-occurrence matrix is $A$ with $n$ rows corresponding to $n$ words. We obtain a full matrix decomposition, with the singular values ordered in the diagonal $S$ matrix, and our new, shorter length-$k$ word vectors in $U_k$.</p><h3 id="SVD"><a href="#SVD" class="headerlink" title="SVD"></a>SVD</h3><p><strong>Eigenvalues</strong> quantify the importance of information along the line of <strong>eigenvectors</strong>. Equipped with this information, we know what part of the information can be ignored and how to compress information (SVD, Dimension reduction &amp; PCA). It also helps us to extract features in developing machine learning models. Sometimes, it makes the model easier to train because of the reduction of tangled information. It also serves the purpose to visualize tangled raw data.</p><p>for Eigenvalues $\lambda$ and Eigenvector $V$, we have:</p><script type="math/tex; mode=display">AV = \lambda V</script><p>the dimension of A is $\mathbb{R}^{n\cdot n}$ and $V$ is a $\mathbb{R}^{n\cdot 1}$ vector.</p><h4 id="Diagonalizable"><a href="#Diagonalizable" class="headerlink" title="Diagonalizable"></a>Diagonalizable</h4><p>Let’s assume a matrix A has two eigenvalues and eigenvectors.</p><script type="math/tex; mode=display">Av_1 = \lambda_1 v_1</script><script type="math/tex; mode=display">Av_2 = \lambda_2 v_2</script><p>We can concatenate them together and rewrite the equations in the matrix form.</p><script type="math/tex; mode=display">A \begin{bmatrix} v1 & v2 \end{bmatrix} = \begin{bmatrix} \lambda_1 v_1 & \lambda_2 v_2 \end{bmatrix} = \begin{bmatrix} v1 & v2 \end{bmatrix} \begin{bmatrix} \lambda_1 & 0 \\ 0 & \lambda_2 \end{bmatrix}</script><p>We can generalize it into any number of eigenvectors as</p><script type="math/tex; mode=display">AV = V\land</script><p>A square matrix A is diagonalizable if we can convert it into a diagonal matrix, like</p><script type="math/tex; mode=display">V^{-1} A V = \land</script><p>An n × n square matrix is diagonalizable if it has n linearly independent eigenvectors. If a matrix is symmetric, it is diagonalizable. If a matrix does not have repeated eigenvalue, it always generates enough linearly independent eigenvectors to diagonalize a vector. If it has repeated eigenvalues, there is no guarantee we have enough eigenvectors. Some will not be diagonalizable.</p><p>If $A$ is a square matrix with $N$ linearly independent eigenvectors ($v_1$, $v_2$, $\cdots$, $v_n$) and corresponding eigenvalues ($\lambda_1$, $\lambda_2$, $\cdots$, $\lambda_n$), we can rearrange</p><script type="math/tex; mode=display">V^{-1} A V = \land</script><p>into </p><script type="math/tex; mode=display">A = V \land V^{-1}</script><p>For example,</p><p><img src="diagonalizable.png" alt></p><h4 id="Singular-vectors-amp-singular-values"><a href="#Singular-vectors-amp-singular-values" class="headerlink" title="Singular vectors &amp; singular values"></a>Singular vectors &amp; singular values</h4><p>However, the above method is possible only if $A$ is a square matrix and $A$ has n linearly independent eigenvectors. Now, it is time to develop a solution for all matrices using SVD.</p><p>The matrix $AA^{T}$ and $A^{T}A$ are very special in linear algebra. Consider any m × n matrix A, we can multiply it with $A^{T}$ to form $AA^{T}$ and $A^{T}A$ separately. These matrices are</p><ul><li>symmetrical,</li><li>square,</li><li>at least positive semidefinite (eigenvalues are zero or positive),</li><li>both matrices have the same positive eigenvalues, and</li><li>both have the same rank r as A.</li></ul><p>We name the eigenvectors for $AA^{T}$ as $u_i$ and $A^{T}A$ as $v_i$ here and call these sets of eigenvectors $u$ and $v$ the <strong>singular vectors</strong> of A. Both matrices have the same positive eigenvalues. The square roots of these eigenvalues are called <strong>singular values</strong>. We concatenate vectors $u_i$ into $U$ and $v_i$ into $V$ to form orthogonal matrices.</p><p><strong>SVD states that any matrix A can be factorized as</strong>:</p><script type="math/tex; mode=display">A_{m\cdot n} = U_{m\cdot m} S_{m\cdot n} V_{n\cdot n}^{T}</script><p>S is a diagonal matrix with r elements equal to the root of the positive eigenvalues of $AA^{T}$ or $A^{T}A$ (both matrics have the same positive eigenvalues anyway).</p><p><img src="usv.png" alt></p><h4 id="Applying-SVD-to-the-cooccurrence-matrix"><a href="#Applying-SVD-to-the-cooccurrence-matrix" class="headerlink" title="Applying SVD to the cooccurrence matrix"></a>Applying SVD to the cooccurrence matrix</h4><p><img src="svd.png" alt="Picture of an SVD"></p><p>This reduced-dimensionality co-occurrence representation preserves semantic relationships between words, e.g. <em>doctor</em> and <em>hospital</em> will be closer than <em>doctor</em> and <em>dog</em>. </p><p>Although these methods give us word vectors that are more than sufficient to encode semantic and syntactic (part of speech) information but are associated with many other problems:</p><ul><li>The dimensions of the matrix change very often (new words are added very frequently and corpus changes in size).</li><li>The matrix is extremely sparse since most words do not co-occur.</li><li>The matrix is very high dimensional in general (≈ 10e6 × 10e6)</li><li>Quadratic cost to train (i.e. to perform SVD)</li><li>Requires the incorporation of some hacks on X to account for the drastic imbalance in word frequency</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_co_occurrence_matrix</span><span class="params">(corpus, window_size=<span class="number">4</span>)</span>:</span></span><br><span class="line">    <span class="string">""" Compute co-occurrence matrix for the given corpus and window_size (default of 4).</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">        Note: Each word in a document should be at the center of a window. Words near edges will have a smaller</span></span><br><span class="line"><span class="string">              number of co-occurring words.</span></span><br><span class="line"><span class="string">              </span></span><br><span class="line"><span class="string">              For example, if we take the document "START All that glitters is not gold END" with window size of 4,</span></span><br><span class="line"><span class="string">              "All" will co-occur with "START", "that", "glitters", "is", and "not".</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">        Params:</span></span><br><span class="line"><span class="string">            corpus (list of list of strings): corpus of documents</span></span><br><span class="line"><span class="string">            window_size (int): size of context window</span></span><br><span class="line"><span class="string">        Return:</span></span><br><span class="line"><span class="string">            M (numpy matrix of shape (number of corpus words, number of corpus words)): </span></span><br><span class="line"><span class="string">                Co-occurence matrix of word counts. </span></span><br><span class="line"><span class="string">                The ordering of the words in the rows/columns should be the same as the ordering of the words given by the distinct_words function.</span></span><br><span class="line"><span class="string">            word2Ind (dict): dictionary that maps word to index (i.e. row/column number) for matrix M.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    words, num_words = distinct_words(corpus)</span><br><span class="line">    M = <span class="keyword">None</span></span><br><span class="line">    word2Ind = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    word2Ind = &#123;word:idx <span class="keyword">for</span> word,idx <span class="keyword">in</span> zip(words, range(num_words))&#125;</span><br><span class="line">    M = np.zeros((num_words,num_words))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> doc <span class="keyword">in</span> corpus:</span><br><span class="line">        <span class="keyword">for</span> index, central_word <span class="keyword">in</span> enumerate(doc):</span><br><span class="line">            left = max(<span class="number">0</span>,index - window_size)</span><br><span class="line">            right = min(num_words, index + window_size+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> context_word <span class="keyword">in</span> doc[left:right]:</span><br><span class="line">                <span class="keyword">if</span> context_word == central_word:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                M[word2Ind[central_word]][word2Ind[context_word]] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> M, word2Ind</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduce_to_k_dim</span><span class="params">(M, k=<span class="number">2</span>)</span>:</span></span><br><span class="line">    <span class="string">""" Reduce a co-occurence count matrix of dimensionality (num_corpus_words, num_corpus_words)</span></span><br><span class="line"><span class="string">        to a matrix of dimensionality (num_corpus_words, k) using the following SVD function from Scikit-Learn:</span></span><br><span class="line"><span class="string">            - http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.TruncatedSVD.html</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">        Params:</span></span><br><span class="line"><span class="string">            M (numpy matrix of shape (number of corpus words, number of corpus words)): co-occurence matrix of word counts</span></span><br><span class="line"><span class="string">            k (int): embedding size of each word after dimension reduction</span></span><br><span class="line"><span class="string">        Return:</span></span><br><span class="line"><span class="string">            M_reduced (numpy matrix of shape (number of corpus words, k)): matrix of k-dimensioal word embeddings.</span></span><br><span class="line"><span class="string">                    In terms of the SVD from math class, this actually returns U * S</span></span><br><span class="line"><span class="string">    """</span>    </span><br><span class="line">    n_iters = <span class="number">10</span>     <span class="comment"># Use this parameter in your call to `TruncatedSVD`</span></span><br><span class="line">    M_reduced = <span class="keyword">None</span></span><br><span class="line">    print(<span class="string">"Running Truncated SVD over %i words..."</span> % (M.shape[<span class="number">0</span>]))</span><br><span class="line">    </span><br><span class="line">    t_svd = TruncatedSVD(n_components=k, n_iter = n_iters)</span><br><span class="line">    M_reduced = t_svd.fit_transform(M)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># ------------------</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"Done."</span>)</span><br><span class="line">    <span class="keyword">return</span> M_reduced</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_embeddings</span><span class="params">(M_reduced, word2Ind, words)</span>:</span></span><br><span class="line">    <span class="string">""" Plot in a scatterplot the embeddings of the words specified in the list "words".</span></span><br><span class="line"><span class="string">        NOTE: do not plot all the words listed in M_reduced / word2Ind.</span></span><br><span class="line"><span class="string">        Include a label next to each point.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Params:</span></span><br><span class="line"><span class="string">            M_reduced (numpy matrix of shape (number of unique words in the corpus , k)): matrix of k-dimensioal word embeddings</span></span><br><span class="line"><span class="string">            word2Ind (dict): dictionary that maps word to indices for matrix M</span></span><br><span class="line"><span class="string">            words (list of strings): words whose embeddings we want to visualize</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    print(M_reduced.shape)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i,word <span class="keyword">in</span> enumerate(words):</span><br><span class="line">        x = M_reduced[i][<span class="number">0</span>]</span><br><span class="line">        y = M_reduced[i][<span class="number">1</span>]</span><br><span class="line">        plt.scatter(x, y, marker=<span class="string">'x'</span>, color=<span class="string">'red'</span>)</span><br><span class="line">        plt.text(x, y, word, fontsize=<span class="number">9</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><h2 id="Iteration-Based-Methods-Word2vec"><a href="#Iteration-Based-Methods-Word2vec" class="headerlink" title="Iteration Based Methods - Word2vec"></a>Iteration Based Methods - Word2vec</h2><p>Instead of computing and storing global information about some huge dataset (which might be billions of sentences), we can try to create a model that will be able to learn one iteration at a time and eventually be able to encode the probability of a word given its context. The idea is to design a model whose parameters are the word vec- tors. Then, train the model on a certain objective. At every iteration we run our model, evaluate the errors, and follow an update rule that has some notion of penalizing the model parameters that caused the error. Thus, we learn our word vectors.</p><p>Word2vec is a software package that actually includes :</p><ul><li><strong>2 algorithms</strong>: continuous bag-of-words (CBOW) and skip-gram. CBOW aims to predict a center word from the surrounding context in terms of word vectors. Skip-gram does the opposite, and predicts the distribution (probability) of context words from a center word.</li><li><strong>2 training methods</strong>: negative sampling and hierarchical softmax. Negative sampling defines an objective by sampling negative exam- ples, while hierarchical softmax defines an objective using an efficient tree structure to compute probabilities for all the vocabulary.</li></ul><h3 id="Language-Models"><a href="#Language-Models" class="headerlink" title="Language Models"></a>Language Models</h3><p>First, we need to create such a model that will assign a probability to a sequence of tokens. Let us start with an example:</p><blockquote><p>“The cat jumped over the puddle.”</p></blockquote><p>A good language model will give this sentence a high probability because this is a completely valid sentence, syntactically and semantically. Mathematically, we can call this probability on any given sequence of n words:</p><script type="math/tex; mode=display">P(w_1,w_2,\cdots,w_n)</script><p>We can take the unary language model approach and break apart this probability by assuming the word occurrences are completely independent:</p><script type="math/tex; mode=display">P(w_1,w_2,\cdots,w_n) = \prod_{i=1}^{n} P(w_i)</script><p>However, we know this is a bit ludicrous because we know the next word is highly contingent upon the previous sequence of words. And the silly sentence example might actually score highly. So perhaps we let the probability of the sequence depend on the pairwise probability of a word in the sequence and the word next to it. We call this the bigram model and represent it as: </p><script type="math/tex; mode=display">P(w_1,w_2,\cdots,w_n) = \prod_{i=1}^{n} P(w_i|w_{i-1})</script><p>Again this is certainly a bit naive since we are only concerning ourselves with pairs of neighboring words rather than evaluating a whole sentence, but as we will see, this representation gets us pretty far along.</p><h3 id="Skip-gram"><a href="#Skip-gram" class="headerlink" title="Skip-gram"></a>Skip-gram</h3><p>One approach is to create a model such that given the center word “jumped”, the model will be able to predict or generate the surrounding words “The”, “cat”, “over”, “the”, “puddle”. Here we call the word “jumped” the context. We call this type of model a Skip-Gram model.<br><img src="Skip.png" alt><br><img src="Skip_2.png" alt></p><p>We breakdown the way this model works in these 6 steps:</p><ol><li>We generate our one hot input vector $x \in \mathbb{R}^{|v|}$ of the center word.</li><li>We get our embedded word vector for the center word<script type="math/tex; mode=display">v_c = Vx  \qquad \in \mathbb{R}^{|v|}</script></li><li>Generate a score vector<script type="math/tex; mode=display">z = Uv_c  \qquad \in \mathbb{R}^{|v|}</script></li><li>Turn the score vector into probabilities,$\hat{y} = softmax(z)$<script type="math/tex; mode=display">\hat y_{c-m}, \cdots, \hat y_{c-1}, \cdots, \hat y_{c+m}</script></li><li>We desire our probability vector generated to match the true prob- abilities which is the one hot vectors of the actual output.<script type="math/tex; mode=display">y_{c-m}, \cdots, y_{c-1}, \cdots, y_{c+m}</script></li></ol><h4 id="Objective-function"><a href="#Objective-function" class="headerlink" title="Objective function"></a>Objective function</h4><p><img src="objective.png" alt></p><p><strong> How to calculate $P(o|c)$? We will use two vectors per word w</strong>:</p><ul><li>$V_w$ when w is a center word</li><li>$U_w$ when w is a context word</li></ul><p>Then for a center word c and a context word o:</p><script type="math/tex; mode=display">P(o|c) = \frac{exp^{u_o^{T}v_c}}{\sum_{w\in v}exp^{u_w^{T}v_c}}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SkipGram</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="string">"""x --&gt; batch_size x word_index</span></span><br><span class="line"><span class="string">       output --&gt; batch_size x context_predicted x vocabulary"""</span>    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, vocabulary_size, embedding_features, context_len, padding_idx=<span class="number">0</span> )</span>:</span></span><br><span class="line">        super(SkipGram, self).__init__()</span><br><span class="line">        self.context_len = context_len</span><br><span class="line">        self.embedding = nn.Embedding(num_embeddings = vocabulary_size, embedding_dim=embedding_features, padding_idx=padding_idx)</span><br><span class="line">        self.fc = nn.Linear(in_features = embedding_features, out_features = vocabulary_size)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        context_out = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.context_len):</span><br><span class="line">            wordvec_x = self.embedding(x)</span><br><span class="line">            context_word_i = self.fc(wordvec_x)</span><br><span class="line">            context_out.append(context_word_i)</span><br><span class="line">        log_prob = F.log_softmax(torch.stack(context_out, dim=<span class="number">1</span>).squeeze(), dim=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> log_prob</span><br><span class="line"></span><br><span class="line">loss_function = nn.NLLLoss()</span><br><span class="line">model = SkipGram()</span><br><span class="line">log_prob = model(centre_word)</span><br><span class="line">loss=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(log_prob.shape[<span class="number">1</span>]):</span><br><span class="line">    loss_i = loss_function(log_prob[:,i,], context_word_i[:,i])</span><br><span class="line">    loss *= loss_i</span><br><span class="line">loss = loss/(i+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="Continuous-Bag-of-Words-Model-CBOW"><a href="#Continuous-Bag-of-Words-Model-CBOW" class="headerlink" title="Continuous Bag of Words Model (CBOW)"></a>Continuous Bag of Words Model (CBOW)</h3><p>Another approach is to treat {“The”, “cat”, ’over”, “the’, “puddle”} as a <strong>context</strong> and from these words, be able to predict or generate the <strong>center word</strong> “jumped”. This type of model we call a Continuous Bag of Words (CBOW) Model.</p><p><img src="CBOW.png" alt></p><p>We breakdown the way this model works in these steps:</p><ol><li>We generate our one hot word vectors for the input context of size m:<script type="math/tex; mode=display">x^{(c−m)},\cdots,x^{(c−1)},x^{(c+1)},\cdots,x^{(c+m)}\in\mathbb{R}^{|v|}</script></li><li>We get our embedded word vectors for the context:<script type="math/tex; mode=display">V_{c-m} = Vx^{(c−m)},V_{c-m+1} = Vx^{(c−m+1)},\cdots,V_{c+m} = Vx^{(c+m)}</script></li><li>Average these vectors to get <script type="math/tex; mode=display">\hat{v} = \frac{v_{c-m} + v_{c-m+1} + \cdots + v_{c+m}}{2m}</script></li><li>Generate a score vector <script type="math/tex; mode=display">z = U\hat{v}  \qquad \in \mathbb{R}^{|v|}</script>As dot product of similar vectors is higher, it will push similar words close to each other in order to achieve a high score.</li><li>Turnthescoresintoprobabilities <script type="math/tex; mode=display">\hat{y} = softmax(z)  \qquad \in \mathbb{R}^{|v|}</script></li><li>We desire our probabilities generated, $\hat{y} \in \mathbb{R}^{|v|}$, to match the true probabilities, $y \in \mathbb{R}^{|v|}$ which also happens to be the one hot vector of the actual word.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBOW</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="string">"""input  -- &gt; batch_size x context_size</span></span><br><span class="line"><span class="string">       output --&gt; batch_size x vocabulary"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, vocabulary_size, embedding_features, padding_idx=<span class="number">0</span>)</span>:</span></span><br><span class="line">        <span class="string">"""nn.Embedding holds a tensor of dimmension (vocabulary_size, feature_size)--&gt;N(0,1)"""</span></span><br><span class="line">        super(CBOW, self).__init__()</span><br><span class="line">        self.embedding = nn.Embedding(num_embeddings = vocabulary_size, embedding_dim = embedding_features, padding_idx=padding_idx)</span><br><span class="line">        self.fc = nn.Linear(in_features = embedding_features, out_features = vocabulary_size)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, context_words)</span>:</span></span><br><span class="line">        wordvecs = self.embedding(context_words)</span><br><span class="line">        mean_wordvecs = wordvecs.sum(dim=<span class="number">1</span>)/x.shape[<span class="number">1</span>] </span><br><span class="line">        log_prob = F.log_softmax(self.fc(mean_wordvecs), dim=<span class="number">1</span>).unsqueeze(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> log_prob</span><br><span class="line"></span><br><span class="line">loss_function = nn.NLLLoss()</span><br><span class="line">model  = CBOW()</span><br><span class="line">log_prob = model(context_words)</span><br><span class="line">loss = loss_function(log_prob.squeeze(), centre_word.squeeze())</span><br></pre></td></tr></table></figure><h3 id="Negative-Sampling"><a href="#Negative-Sampling" class="headerlink" title="Negative Sampling"></a>Negative Sampling</h3><p>Lets take a second to look at the objective function. Note that the summation over |V| is computationally huge! Any update we do or evaluation of the objective function would take O(|V|) time which if we recall is in the millions. A simple idea is we could instead just approximate it.</p><p><strong>For every training step, instead of looping over the entire vocabulary, we can just sample several negative examples!</strong> We “sample” from a noise distribution $P_n(w)$ whose probabilities match the ordering of the frequency of the vocabulary. Unlike the probabilistic model of Word2Vec where for each input word probability is computed from all the target words in the vocabulary, here for each input word has only few target words (few true and rest randomly selected false targets). <strong>The key difference compared to the probabilistic model is the use of sigmoid activation as final discriminator replacing softmax function in the probabilistic model.</strong></p><p>Given this example(We get positive example by using the same skip-grams technique, a fixed window that goes around):</p><blockquote><p>“I want a glass of orange juice to go along with my cereal”</p></blockquote><p>The sampling will look like this:</p><div class="table-container"><table><thead><tr><th style="text-align:left">Context</th><th style="text-align:left">Word</th><th style="text-align:left">target</th></tr></thead><tbody><tr><td style="text-align:left">orange</td><td style="text-align:left">juice</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">orange</td><td style="text-align:left">king</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">orange</td><td style="text-align:left">book</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">orange</td><td style="text-align:left">the</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">orange</td><td style="text-align:left">of</td><td style="text-align:left">0</td></tr></tbody></table></div><p>So the steps to generate the samples are:</p><ol><li>Pick a positive context</li><li>Pick a k negative contexts from the dictionary.<br>We will have a k negative examples to 1 positive ones in the data we are collecting.</li></ol><p><img src="negative_sampling.png" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Merge</span><br><span class="line"><span class="keyword">from</span> keras.layers.core <span class="keyword">import</span> Dense, Reshape</span><br><span class="line"><span class="keyword">from</span> keras.layers.embeddings <span class="keyword">import</span> Embedding</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"></span><br><span class="line"><span class="comment"># build skip-gram architecture</span></span><br><span class="line">word_model = Sequential()</span><br><span class="line">word_model.add(Embedding(vocab_size, embed_size,</span><br><span class="line">                         embeddings_initializer=<span class="string">"glorot_uniform"</span>,</span><br><span class="line">                         input_length=<span class="number">1</span>))</span><br><span class="line">word_model.add(Reshape((embed_size, )))</span><br><span class="line"></span><br><span class="line">context_model = Sequential()</span><br><span class="line">context_model.add(Embedding(vocab_size, embed_size,</span><br><span class="line">                  embeddings_initializer=<span class="string">"glorot_uniform"</span>,</span><br><span class="line">                  input_length=<span class="number">1</span>))</span><br><span class="line">context_model.add(Reshape((embed_size,)))</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Merge([word_model, context_model], mode=<span class="string">"dot"</span>))</span><br><span class="line">model.add(Dense(<span class="number">1</span>, kernel_initializer=<span class="string">"glorot_uniform"</span>, activation=<span class="string">"sigmoid"</span>))</span><br><span class="line">model.compile(loss=<span class="string">"mean_squared_error"</span>, optimizer=<span class="string">"rmsprop"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## training</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">6</span>):</span><br><span class="line">    loss = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, elem <span class="keyword">in</span> enumerate(skip_grams):</span><br><span class="line">        pair_first_elem = np.array(list(zip(*elem[<span class="number">0</span>]))[<span class="number">0</span>], dtype=<span class="string">'int32'</span>)</span><br><span class="line">        pair_second_elem = np.array(list(zip(*elem[<span class="number">0</span>]))[<span class="number">1</span>], dtype=<span class="string">'int32'</span>)</span><br><span class="line">        labels = np.array(elem[<span class="number">1</span>], dtype=<span class="string">'int32'</span>)</span><br><span class="line">        X = [pair_first_elem, pair_second_elem]</span><br><span class="line">        Y = labels</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">10000</span> == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">'Processed &#123;&#125; (skip_first, skip_second, relevance) pairs'</span>.format(i))</span><br><span class="line">        loss += model.train_on_batch(X,Y)  </span><br><span class="line"></span><br><span class="line">    print(<span class="string">'Epoch:'</span>, epoch, <span class="string">'Loss:'</span>, loss)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## get word embedding</span></span><br><span class="line">merge_layer = model.layers[<span class="number">0</span>]</span><br><span class="line">word_model = merge_layer.layers[<span class="number">0</span>]</span><br><span class="line">word_embed_layer = word_model.layers[<span class="number">0</span>]</span><br><span class="line">weights = word_embed_layer.get_weights()[<span class="number">0</span>][<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">print(weights.shape)</span><br><span class="line">pd.DataFrame(weights, index=id2word.values()).head()</span><br></pre></td></tr></table></figure><h3 id="hierarchical-softmax"><a href="#hierarchical-softmax" class="headerlink" title="hierarchical softmax"></a>hierarchical softmax</h3><p>hierarchical softmax is a much more efficient alternative to the normal softmax. In practice, hierarchical softmax tends to be better for infrequent words, while negative sampling works better for frequent words and lower dimensional vectors.</p><p>Hierarchical softmax uses a binary tree to represent all words in the vocabulary. Each leaf of the tree is a word, and there is a unique path from root to leaf. In this model, there is no output representation for words. Instead, each node of the graph (except the root and the leaves) is associated to a vector that the model is going to learn.</p><p>In this model, the probability of a word w given a vector $w_i$, p(w|w_i),is equal to the probability of a random walk starting in the root and ending in the leaf node corresponding to w. The main advantage in computing the probability this way is that the cost is only O(log(|V|)), corresponding to the length of the path.<br><img src="hafftree.png" alt></p><p>Taking $w_2$ in above figure, we must take two left edges and<br>then a right edge to reach w2 from the root, so</p><script type="math/tex; mode=display">p(w_2) = p(n(w_2,1),left) \cdot p(n(w_2,2),left) \cdot p(n(w_2,3),right) \\ = \sigma({\theta_{n(w_2,1)}}^T \cdot h) \cdot \sigma({\theta_{n(w_2,2)}}^T \cdot h) \cdot \sigma({-\theta_{n(w_2,3)}}^T \cdot h)</script><p>Therefore,</p><script type="math/tex; mode=display">p(w)=\prod_{j=1}^{L(w)-1}\sigma( sign(w,j)\cdot {\theta_{n(w,j)}}^Th )</script><script type="math/tex; mode=display">sign(w,j)= \begin{cases} 1, & \text{if n(w,j+1) is the left child of n(w,j)} \\ -1,& \text{if n(w,j+1) is the right child of n(w,j)}\end{cases}</script><ul><li>$\theta_{n(w,j)}$ is the vector representation of $n(w,j)$</li><li>$h$ is the output of hidden layer</li></ul><h3 id="Global-Vectors-for-Word-Representation-GloVe"><a href="#Global-Vectors-for-Word-Representation-GloVe" class="headerlink" title="Global Vectors for Word Representation (GloVe)"></a>Global Vectors for Word Representation (GloVe)</h3><p>So far, we have looked at two main classes of methods to find word embeddings. </p><ul><li>The first set are count-based and rely on matrix factor- ization (e.g. LSA, HAL). While these methods effectively leverage global statistical information, they are primarily used to capture word similarities and do poorly on tasks such as word analogy, indi- cating a sub-optimal vector space structure. </li><li>The other set of methods are shallow window-based (e.g. the skip-gram and the CBOW mod- els), which learn word embeddings by making predictions in local context windows. These models demonstrate the capacity to capture complex linguistic patterns beyond word similarity, but fail to make use of the global co-occurrence statistics.</li></ul><p>In comparison, GloVe consists of a weighted least squares model that trains on global word-word co-occurrence counts and thus makes efficient use of statistics. The model produces a word vector space with meaningful sub-structure. It shows state-of-the-art per- formance on the word analogy task, and outperforms other current methods on several word similarity tasks.</p><ol><li>Construct co-occurrence Matrix</li><li>Construct relationships between word vectors and co-occurrence Matrix<ul><li>Let X denote the word-word co-occurrence matrix, where $X_{ij}$ indicates the number of times word j occur in the context of word i</li><li>$w_{i}$,$\tilde{w_{j}}$ is the word vector</li><li>$b_i,b_j$ is the bias term<script type="math/tex; mode=display">w_{i}^{T}\tilde{w_{j}} + b_i + \tilde{b_j} = \log(X_{ij}) \tag{1}</script></li></ul></li><li>Construct loss function: Mean Square Loss<script type="math/tex; mode=display">J = \sum_{i,j=1}^{V} f(X_{ij})(w_{i}^{T}\tilde{w_{j}} + b_i + \tilde{b_j} – \log(X_{ij}) )^2</script><script type="math/tex; mode=display">f(x)=\begin{equation} \begin{cases} (x/x_{max})^{\alpha}  & \text{if} \ x < x_{max} \\ 1 & \text{otherwise} \end{cases} \end{equation}</script></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">weight_func</span><span class="params">(x, x_max, alpha)</span>:</span></span><br><span class="line">    wx = (x/x_max)**alpha</span><br><span class="line">    wx = torch.min(wx, torch.ones_like(wx))</span><br><span class="line">    <span class="keyword">return</span> wx</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wmse_loss</span><span class="params">(weights, inputs, targets)</span>:</span></span><br><span class="line">    loss = weights * F.mse_loss(inputs, targets, reduction=<span class="string">'none'</span>)</span><br><span class="line">    <span class="keyword">return</span> torch.mean(loss)</span><br><span class="line"></span><br><span class="line">EMBED_DIM = <span class="number">300</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GloveModel</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_embeddings, embedding_dim)</span>:</span></span><br><span class="line">        super(GloveModel, self).__init__()</span><br><span class="line">        self.wi = nn.Embedding(num_embeddings, embedding_dim)</span><br><span class="line">        self.wj = nn.Embedding(num_embeddings, embedding_dim)</span><br><span class="line">        self.bi = nn.Embedding(num_embeddings, <span class="number">1</span>)</span><br><span class="line">        self.bj = nn.Embedding(num_embeddings, <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        self.wi.weight.data.uniform_(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">        self.wj.weight.data.uniform_(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">        self.bi.weight.data.zero_()</span><br><span class="line">        self.bj.weight.data.zero_()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, i_indices, j_indices)</span>:</span></span><br><span class="line">        w_i = self.wi(i_indices)</span><br><span class="line">        w_j = self.wj(j_indices)</span><br><span class="line">        b_i = self.bi(i_indices).squeeze()</span><br><span class="line">        b_j = self.bj(j_indices).squeeze()</span><br><span class="line">        </span><br><span class="line">        x = torch.sum(w_i * w_j, dim=<span class="number">1</span>) + b_i + b_j</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">glove = GloveModel(dataset._vocab_len, EMBED_DIM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">outputs = glove(i_idx, j_idx)</span><br><span class="line">weights_x = weight_func(x_ij, X_MAX, ALPHA)</span><br><span class="line">loss = wmse_loss(weights_x, outputs, torch.log(x_ij))</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>In conclusion, the GloVe model efficiently leverages global statistical information by training only on the nonzero elements in a word- word co-occurrence matrix, and produces a vector space with mean- ingful sub-structure. It consistently outperforms word2vec on the word analogy task, given the same corpus, vocabulary, window size, and training time. It achieves better results faster, and also obtains the best results irrespective of speed.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Course note and slides of <a href="http://web.stanford.edu/class/cs224n/" target="_blank" rel="noopener">cs224n</a></li><li><a href="https://medium.com/@jonathan_hui/machine-learning-singular-value-decomposition-svd-principal-component-analysis-pca-1d45e885e491" target="_blank" rel="noopener">Machine Learning — Singular Value Decomposition (SVD) &amp; Principal Component Analysis (PCA)</a></li><li><a href="https://lilianweng.github.io/lil-log/2017/10/15/learning-word-embedding.html" target="_blank" rel="noopener">https://lilianweng.github.io/lil-log/2017/10/15/learning-word-embedding.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/42651829" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/42651829</a></li><li><a href="https://nlpython.com/implementing-glove-model-with-pytorch/" target="_blank" rel="noopener">https://nlpython.com/implementing-glove-model-with-pytorch/</a></li></ul>]]></content>
    
    <summary type="html">
    
      Word Vectors Summary
    
    </summary>
    
    
      <category term="Artificial Intelligence" scheme="https://zhangruochi.com/categories/Artificial-Intelligence/"/>
    
      <category term="Deep Learning" scheme="https://zhangruochi.com/categories/Artificial-Intelligence/Deep-Learning/"/>
    
    
      <category term="cs224n" scheme="https://zhangruochi.com/tags/cs224n/"/>
    
  </entry>
  
  <entry>
    <title>Composition</title>
    <link href="https://zhangruochi.com/Composition/2019/12/01/"/>
    <id>https://zhangruochi.com/Composition/2019/12/01/</id>
    <published>2019-12-02T01:25:39.000Z</published>
    <updated>2019-12-02T02:36:34.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="What-is-Composition"><a href="#What-is-Composition" class="headerlink" title="What is Composition?"></a>What is Composition?</h2><ol><li>组合是指将不同的部分结合成一个整体的行为。使用面向对象的组合技术，可以将简单的、独立的对象组合成更大更复杂的整体。</li><li>从本质上讲，参与组合的那些对象都很小，他们在结构上都是独立的。这使得他们能够无缝低转换为可插入、可互换的组件。</li></ol><h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><h3 id="创建零件"><a href="#创建零件" class="headerlink" title="创建零件"></a>创建零件</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span></span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:size</span>, <span class="symbol">:parts</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(args = &#123;&#125;)</span></span></span><br><span class="line">        @size = args[<span class="symbol">:size</span>]</span><br><span class="line">        @parts = args[<span class="symbol">:parts</span>]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spares</span></span></span><br><span class="line">        parts.spares</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parts</span> &lt; Array</span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:parts</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(parts)</span></span></span><br><span class="line">        @parts = parts</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spares</span></span></span><br><span class="line">        parts.select &#123;<span class="params">|part|</span> part.needs_spare&#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span></span></span><br><span class="line">        parts.size</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Part</span></span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:name</span>, <span class="symbol">:description</span>, <span class="symbol">:needs_spare</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(args)</span></span></span><br><span class="line">        @name = args[<span class="symbol">:name</span>]</span><br><span class="line">        @description = args[<span class="symbol">:description</span>]</span><br><span class="line">        @needs_spare = args.fetch(<span class="symbol">:needs_spare</span>,<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">chain = Part.new(<span class="symbol">name:</span> <span class="string">"chain"</span>, <span class="symbol">description:</span> <span class="string">'10-speed'</span>)</span><br><span class="line">road_tire = Part.new(<span class="symbol">name:</span> <span class="string">"tire_size"</span>, <span class="symbol">description:</span> <span class="string">'23'</span>)</span><br><span class="line">tape = Part.new(<span class="symbol">name:</span> <span class="string">"tape_color"</span>, <span class="symbol">description:</span> <span class="string">'red'</span>)</span><br><span class="line">mountain_tire = Part.new(<span class="symbol">name:</span> <span class="string">"tire_size"</span>, <span class="symbol">description:</span> <span class="string">'2.1'</span>)</span><br><span class="line">rear_shock = Part.new(<span class="symbol">name:</span> <span class="string">"rear_shock"</span>, <span class="symbol">description:</span> <span class="string">'Fox'</span>)</span><br><span class="line">front_shock = Part.new(<span class="symbol">name:</span> <span class="string">'front_shock'</span>, <span class="symbol">description:</span> <span class="string">'Manitou'</span>, <span class="symbol">needs_spare:</span> <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><h3 id="组装"><a href="#组装" class="headerlink" title="组装"></a>组装</h3><p>此时<code>size</code>能正常响应，但是不能执行数组之间的加法会导致问题. 尽管<code>+</code>连接的是 <code>Parts</code> 对象，但是<code>+</code> 返回的对象是 <code>Array</code>实例。<code>Array</code>并不知道如何响应<code>spares</code></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">road_bike_parts = Parts.new([chain, road_tire, tape])</span><br><span class="line">p road_bike_parts.spares</span><br><span class="line">p road_bike_parts.size</span><br></pre></td></tr></table></figure><h3 id="让Parts对象更像一个数组"><a href="#让Parts对象更像一个数组" class="headerlink" title="让Parts对象更像一个数组"></a>让Parts对象更像一个数组</h3><ol><li>The Forwardable module<br>Forwardable is a module that can be used to add behavior to all the <strong>instances</strong> of a given class. This module is included to the singleton class using the extend keyword in order to add methods at class-level (to keep it simple).</li><li>The Forwardable#def_delegator method allows an object to forward a message to a defined receiver.<ul><li>The first argument correspond to the receiver of the message forwarding.</li><li>The second argument is the message to forward.</li><li>And finally the third argument is an alias of the message.</li></ul></li><li>The def_delegators method</li><li>The delegate method<br> The delegate method accepts a hash as argument where:<ul><li>the key is one or more messages</li><li>the value is the receiver of the messages defined as key<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># in forwardable.rb</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'forwardable'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span></span></span><br><span class="line">  attr <span class="symbol">:cores</span>, <span class="symbol">:screens</span></span><br><span class="line">  extend Forwardable</span><br><span class="line">  delegate %I[size]   =&gt; <span class="symbol">:</span>@cores,</span><br><span class="line">           %I[length] =&gt; <span class="symbol">:</span>@screens</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">    @cores  = (<span class="number">1</span>..<span class="number">8</span>).to_a</span><br><span class="line">    @screens = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">macrosoft = Computer.new</span><br><span class="line">puts <span class="string">"Cores:   <span class="subst">#&#123;macrosoft.size&#125;</span>"</span></span><br><span class="line">puts <span class="string">"Screens: <span class="subst">#&#123;macrosoft.length&#125;</span>"</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p>The 2 main differences with the def_delegator method is that it takes a set of methods to forward and the methods cannot be aliased<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'forwardable'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span></span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:size</span>, <span class="symbol">:parts</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(args = &#123;&#125;)</span></span></span><br><span class="line">        @size = args[<span class="symbol">:size</span>]</span><br><span class="line">        @parts = args[<span class="symbol">:parts</span>]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spares</span></span></span><br><span class="line">        parts.spares</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parts</span></span></span><br><span class="line">    extend Forwardable</span><br><span class="line">    def_delegators <span class="symbol">:</span>@parts, <span class="symbol">:size</span>, <span class="symbol">:each</span></span><br><span class="line">    <span class="keyword">include</span> Enumerable</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(parts)</span></span></span><br><span class="line">        @parts = parts</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spares</span></span></span><br><span class="line">        select &#123;<span class="params">|part|</span> part.needs_spare&#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Part</span></span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:name</span>, <span class="symbol">:description</span>, <span class="symbol">:needs_spare</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(args)</span></span></span><br><span class="line">        @name = args[<span class="symbol">:name</span>]</span><br><span class="line">        @description = args[<span class="symbol">:description</span>]</span><br><span class="line">        @needs_spare = args.fetch(<span class="symbol">:needs_spare</span>,<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">chain = Part.new(<span class="symbol">name:</span> <span class="string">"chain"</span>, <span class="symbol">description:</span> <span class="string">'10-speed'</span>)</span><br><span class="line">road_tire = Part.new(<span class="symbol">name:</span> <span class="string">"tire_size"</span>, <span class="symbol">description:</span> <span class="string">'23'</span>)</span><br><span class="line">tape = Part.new(<span class="symbol">name:</span> <span class="string">"tape_color"</span>, <span class="symbol">description:</span> <span class="string">'red'</span>)</span><br><span class="line">mountain_tire = Part.new(<span class="symbol">name:</span> <span class="string">"tire_size"</span>, <span class="symbol">description:</span> <span class="string">'2.1'</span>)</span><br><span class="line">rear_shock = Part.new(<span class="symbol">name:</span> <span class="string">"rear_shock"</span>, <span class="symbol">description:</span> <span class="string">'Fox'</span>)</span><br><span class="line">front_shock = Part.new(<span class="symbol">name:</span> <span class="string">'front_shock'</span>, <span class="symbol">description:</span> <span class="string">'Manitou'</span>, <span class="symbol">needs_spare:</span> <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">mountain_bike = Bicycle.new(</span><br><span class="line">    <span class="symbol">size:</span> <span class="string">'L'</span>,</span><br><span class="line">    <span class="symbol">parts:</span> Parts.new([chain, mountain_tire, front_shock, rear_shock])</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">road_bike = Bicycle.new(</span><br><span class="line">    <span class="symbol">size:</span> <span class="string">'L'</span>,</span><br><span class="line">    <span class="symbol">parts:</span> Parts.new([chain, road_tire, tape])</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">p mountain_bike.size</span><br><span class="line">p road_bike.size</span><br></pre></td></tr></table></figure></p><h3 id="创建零件工厂"><a href="#创建零件工厂" class="headerlink" title="创建零件工厂"></a>创建零件工厂</h3><p>对象如何创建的知识，最好放在<code>工厂里面</code>。这样你就只需要一个说明书，就能创建对象。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">road_config = [[<span class="string">'chain'</span>,<span class="string">'10-speed'</span>],</span><br><span class="line">               [<span class="string">'tire_size'</span>,<span class="string">'23'</span>],</span><br><span class="line">               [<span class="string">'tape_color'</span>,<span class="string">'red'</span>]</span><br><span class="line">           ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">PartsFactory</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">build</span><span class="params">(config, part_class = Part, parts_class = Parts)</span></span></span><br><span class="line">        parts_class.new(</span><br><span class="line">            config.collect &#123;<span class="params">|part_config|</span></span><br><span class="line">                part_class.new (&#123;</span><br><span class="line">                    <span class="symbol">name:</span> part_config[<span class="number">0</span>],</span><br><span class="line">                    <span class="symbol">description:</span> part_config[<span class="number">1</span>],</span><br><span class="line">                    <span class="symbol">needs_spare:</span> part_config.fetch(<span class="number">2</span>,<span class="literal">true</span>)&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">road_parts = PartsFactory.build(road_config)</span><br><span class="line">p road_parts.spares</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;What-is-Composition&quot;&gt;&lt;a href=&quot;#What-is-Composition&quot; class=&quot;headerlink&quot; title=&quot;What is Composition?&quot;&gt;&lt;/a&gt;What is Composition?&lt;/h2&gt;&lt;ol
      
    
    </summary>
    
    
      <category term="Programming Language" scheme="https://zhangruochi.com/categories/Programming-Language/"/>
    
      <category term="Object Oriented Design" scheme="https://zhangruochi.com/categories/Programming-Language/Object-Oriented-Design/"/>
    
    
  </entry>
  
  <entry>
    <title>Role</title>
    <link href="https://zhangruochi.com/Role/2019/12/01/"/>
    <id>https://zhangruochi.com/Role/2019/12/01/</id>
    <published>2019-12-01T22:18:45.000Z</published>
    <updated>2019-12-02T00:04:00.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="理解角色"><a href="#理解角色" class="headerlink" title="理解角色"></a>理解角色</h2><p>有些问题需要在其他不相关的对象之间共享行为。这种公共行为对类来说是正交的，他是对象所扮演的角色。当之前无关的对象开始扮演某个公共的角色时，他们便与自己扮演的角色所对应的对象之间建立了一层关系，这些关系与经典继承要求的子类/父类关系有所不同，他们不可见，但又确实存在。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Schedule</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scheduled?</span><span class="params">(schedulable, start_date, end_date)</span></span></span><br><span class="line">        puts <span class="string">"this <span class="subst">#&#123;schedulable.<span class="keyword">class</span>&#125;</span> is not schedulable between <span class="subst">#&#123;start_date&#125;</span> and <span class="subst">#&#123;end_date&#125;</span>"</span></span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Schedulable</span></span></span><br><span class="line">    <span class="keyword">attr_writer</span> <span class="symbol">:schedule</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">schedulable?</span><span class="params">(start_date, end_date)</span></span></span><br><span class="line">        !scheduled?(start_date - lead_days, end_date)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scheduled?</span><span class="params">(start_date, end_date)</span></span></span><br><span class="line">        schedule.scheduled?(<span class="keyword">self</span>, start_date, end_date)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_days</span></span></span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span></span></span><br><span class="line">    <span class="keyword">include</span> Schedulable</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_days</span></span></span><br><span class="line">        <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ...... </span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span></span></span><br><span class="line">    <span class="keyword">include</span> Schedulable</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lead_days</span></span></span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ......</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="编写可替代性的代码"><a href="#编写可替代性的代码" class="headerlink" title="编写可替代性的代码"></a>编写可替代性的代码</h2><h3 id="识别出反模式"><a href="#识别出反模式" class="headerlink" title="识别出反模式"></a>识别出反模式</h3><ol><li>使用类似 <code>type</code> 和 <code>category</code> 这类名字的变量来确定发送给<code>self</code>的是何种消息的对象，会包含两个高度相关但又有所不同的对象。</li><li>当某个发送对象要检查接受对象的类以确定所发送的消息时，你一定忽略了某个鸭子类型的存在。</li><li>除了共享接口，鸭子类型也可能共享行为。</li></ol><h3 id="坚持抽象"><a href="#坚持抽象" class="headerlink" title="坚持抽象"></a>坚持抽象</h3><ol><li>抽象父类里的所有代码都应该适用于每一个继承它的类；</li><li>错误的抽象会导致继承对象不正确的行为；</li></ol><h3 id="重视契约"><a href="#重视契约" class="headerlink" title="重视契约"></a>重视契约</h3><p><strong>里氏替换原则</strong>: 对于一个健全的类型系统，其子类必须能够替换他的父类型。</p><h3 id="使用模板方法模式"><a href="#使用模板方法模式" class="headerlink" title="使用模板方法模式"></a>使用模板方法模式</h3><p>用于创建可继承代码的基本编码技术是模板方法模式。这种模式可以让你将抽象与具体分离开来。抽象代码用于定义算法，具体代码可以继承这个抽象，并通过改写这些模板方法来提供特殊化。</p><h3 id="预先将类解耦"><a href="#预先将类解耦" class="headerlink" title="预先将类解耦"></a>预先将类解耦</h3><p>尽量避免编写继承者需要发送super消息的代码。可以通过钩子消息让子类参与进来，同时还可免除它们要知道抽象算法的职责。</p><h3 id="创建浅层结构"><a href="#创建浅层结构" class="headerlink" title="创建浅层结构"></a>创建浅层结构</h3><p>钩子方法的局限性在于它仅适用于创建浅层结构。深层次结构的问题在于，他们定义了一条很长的用于消息查找的搜索路径，并且为对象提供了大量的机会，让他们在那条路径上可以随着消息的传递添加行为。因为对象依赖于它之上的所有事物，所以深层次的结构拥有一个很大的内奸依赖关系集合。深层次结构的另外一个问题在于程序员往往只是对处于顶端和底部的类比较熟悉。</p>]]></content>
    
    <summary type="html">
    
      Using module to share behaviors of objects
    
    </summary>
    
    
      <category term="Programming Language" scheme="https://zhangruochi.com/categories/Programming-Language/"/>
    
      <category term="Object Oriented Design" scheme="https://zhangruochi.com/categories/Programming-Language/Object-Oriented-Design/"/>
    
    
  </entry>
  
  <entry>
    <title>Inheritance</title>
    <link href="https://zhangruochi.com/Inheritance/2019/12/01/"/>
    <id>https://zhangruochi.com/Inheritance/2019/12/01/</id>
    <published>2019-12-01T20:59:25.000Z</published>
    <updated>2019-12-01T21:45:22.203Z</updated>
    
    <content type="html"><![CDATA[<h2 id="What-is-inheritance"><a href="#What-is-inheritance" class="headerlink" title="What is inheritance ?"></a>What is inheritance ?</h2><ol><li>继承的核心是 <code>实现消息的自动委托</code>。</li></ol><h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span></span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:style</span>,<span class="symbol">:size</span>,<span class="symbol">:tape_color</span>,<span class="symbol">:front_shock</span>,<span class="symbol">:rear_shock</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(args)</span></span></span><br><span class="line">        @style = args[<span class="symbol">:style</span>]</span><br><span class="line">        @size = args[<span class="symbol">:size</span>]</span><br><span class="line">        @tape_color = args[<span class="symbol">:tape_color</span>]</span><br><span class="line">        @front_shock = args[<span class="symbol">:front_shock</span>]</span><br><span class="line">        @rear_shock = args[<span class="symbol">:rear_shock</span>]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spares</span></span></span><br><span class="line">        <span class="keyword">if</span> style == <span class="symbol">:read</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="symbol">chain:</span> <span class="string">'10-speed'</span>,</span><br><span class="line">                <span class="symbol">tire_size:</span> <span class="string">'23'</span>, </span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="symbol">chain:</span> <span class="string">'10-speed'</span>,</span><br><span class="line">                <span class="symbol">tire_size:</span> <span class="string">'2.1'</span>,</span><br><span class="line">                <span class="symbol">rear_shock:</span> rear_shock</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ol><li><strong>找出抽象</strong>：子类是其父类的特殊化。子类应该包含父类的一切内容，外加更多内容。任何期待父类的对象应该都能够与其子类进行交互。</li><li><p><strong>创建抽象父类</strong>先将所有的代码下放到子类然后逐渐地、部分地提升是重构操作的重要组成部分。因为一开始只将部分行为下放到子类，然后试图将某个现有的类从具体转换为抽象，那么有可能会不小心残留下具体的行为。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span></span></span><br><span class="line">    <span class="comment"># 这个类为空</span></span><br><span class="line">    <span class="comment"># 所有的代码都移动到了 RoadBike</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoadBike</span> &lt; Bicycle</span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:style</span>,<span class="symbol">:size</span>,<span class="symbol">:tape_color</span>,<span class="symbol">:front_shock</span>,<span class="symbol">:rear_shock</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(args)</span></span></span><br><span class="line">        @style = args[<span class="symbol">:style</span>]</span><br><span class="line">        @size = args[<span class="symbol">:size</span>]</span><br><span class="line">        @tape_color = args[<span class="symbol">:tape_color</span>]</span><br><span class="line">        @front_shock = args[<span class="symbol">:front_shock</span>]</span><br><span class="line">        @rear_shock = args[<span class="symbol">:rear_shock</span>]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spares</span></span></span><br><span class="line">        <span class="keyword">if</span> style == <span class="symbol">:read</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="symbol">chain:</span> <span class="string">'10-speed'</span>,</span><br><span class="line">                <span class="symbol">tire_size:</span> <span class="string">'23'</span>, </span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="symbol">chain:</span> <span class="string">'10-speed'</span>,</span><br><span class="line">                <span class="symbol">tire_size:</span> <span class="string">'2.1'</span>,</span><br><span class="line">                <span class="symbol">rear_shock:</span> rear_shock</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mountain</span> &lt; Bicycle</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>提升抽象行为</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span></span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:size</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(args = &#123;&#125;)</span></span></span><br><span class="line">        @size = args[<span class="symbol">:size</span>]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoadBike</span> &lt; Bicycle</span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:tape_color</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(args)</span></span></span><br><span class="line">        @tape_color = args[<span class="symbol">:tape_color</span>]</span><br><span class="line">        <span class="keyword">super</span>(args)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ......</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mountain</span> &lt; Bicycle</span></span><br><span class="line">    <span class="comment"># ......</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>使用模板方法模式<br>在负类定义好几本结构，并通过发送消息来获取子类特有的实现，这种方法称为<code>模板方法模式</code>。使用模板方法模式的类都必须给它所发送的每一条消息提供一个实现。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span></span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:size</span>,<span class="symbol">:chain</span>,<span class="symbol">:tire_size</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(args = &#123;&#125;)</span></span></span><br><span class="line">        @size = args[<span class="symbol">:size</span>]</span><br><span class="line">        @chain = args[<span class="symbol">:chain</span>] <span class="params">||</span> default_chain</span><br><span class="line">        @tire_size = args[<span class="symbol">:tire_size</span>] <span class="params">||</span> default_tire_size</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">default_chain</span></span></span><br><span class="line">        <span class="string">'10-speed'</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">default_tire_size</span></span></span><br><span class="line">        raise NotImplememtedError</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoadBike</span> &lt; Bicycle</span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:tape_color</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(args)</span></span></span><br><span class="line">        @tape_color = args[<span class="symbol">:tape_color</span>]</span><br><span class="line">        <span class="keyword">super</span>(args)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">default_chain</span></span></span><br><span class="line">        <span class="string">'9-speed'</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mountain</span> &lt; Bicycle</span></span><br><span class="line">    <span class="comment"># ......</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>管理父类和子类之间的耦合<br>一如既往，当知道其他类相关的事情，变回创建依赖关系。发送<code>super</code>消息的子类，不仅需要知道自己在干什么，还需要知道自己与父类是如何交互的。可以使用<strong>钩子消息</strong>解耦子类。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span></span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:size</span>,<span class="symbol">:chain</span>,<span class="symbol">:tire_size</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(args = &#123;&#125;)</span></span></span><br><span class="line">        @size = args[<span class="symbol">:size</span>]</span><br><span class="line">        @chain = args[<span class="symbol">:chain</span>] <span class="params">||</span> default_chain</span><br><span class="line">        @tire_size = args[<span class="symbol">:tire_size</span>] <span class="params">||</span> default_tire_size</span><br><span class="line"></span><br><span class="line">        post_initialize(args)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spares</span></span></span><br><span class="line">        &#123;<span class="symbol">tire_size:</span> tire_size,</span><br><span class="line">            <span class="symbol">chain:</span> chain&#125;.mege(local_spares)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">local_spares</span></span></span><br><span class="line">        &#123;&#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post_initialize</span><span class="params">(args)</span></span></span><br><span class="line">        <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">default_chain</span></span></span><br><span class="line">        <span class="string">'10-speed'</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">default_tire_size</span></span></span><br><span class="line">        raise NotImplememtedError</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoadBike</span> &lt; Bicycle</span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:tape_color</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post_initialize</span><span class="params">(args)</span></span></span><br><span class="line">        @tape_color = args[<span class="symbol">:tape_color</span>]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">local_spares</span></span></span><br><span class="line">        &#123;<span class="symbol">tape_color:</span> tape_color&#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">default_tire_size</span></span></span><br><span class="line">        <span class="string">'23'</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mountain</span> &lt; Bicycle</span></span><br><span class="line">    <span class="comment"># ......</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      Inheritance and Reconstruction
    
    </summary>
    
    
      <category term="Programming Language" scheme="https://zhangruochi.com/categories/Programming-Language/"/>
    
      <category term="Object Oriented Design" scheme="https://zhangruochi.com/categories/Programming-Language/Object-Oriented-Design/"/>
    
    
  </entry>
  
  <entry>
    <title>Interface Segmentation Principle</title>
    <link href="https://zhangruochi.com/Interface-Segmentation-Principle/2019/12/01/"/>
    <id>https://zhangruochi.com/Interface-Segmentation-Principle/2019/12/01/</id>
    <published>2019-12-01T15:32:56.000Z</published>
    <updated>2019-12-01T17:38:20.104Z</updated>
    
    <content type="html"><![CDATA[<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口有很多不同的概念，在这里，这个术语指的是类里的接口。类实现了许多方法，有些方法旨在被其他对象使用，这些方法就组成了它的公共接口。那些组成类的公共接口的方法组成了这个类呈现给外部世界的全貌。他们：</p><ol><li>暴露了其主要的职责</li><li>期望被其它对象调用</li><li>不会因一时兴起而改变</li><li>对其他依赖它的对象来说很安全</li><li>在测试里被详细记录</li></ol><h2 id="领域对象"><a href="#领域对象" class="headerlink" title="领域对象"></a>领域对象</h2><p>Domain Object 显而易见，因为他们代表了这个应用程序，代表了现实世界里的很大的、易于发现的事物。应该要注意的是，Domain Object 往往是给粗心大意设立的陷进。因为如果过度关注他们，就会倾向于给他们强加上行为。<strong>我们应该重点关注的是他们之间的消息传递</strong>，这些消息会引导你去发现其他的对象，而这些对象可远没有这么明显。</p><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p>时序图的价值在于，他们明确制定了对象之间消息的传递。因为对象间只应使用公共接口进行通信，时序图便是一种用于暴露、实验并最终定义这些接口的工具。</p><h2 id="请询问“要什么”，别告知“如何做”"><a href="#请询问“要什么”，别告知“如何做”" class="headerlink" title="请询问“要什么”，别告知“如何做”"></a>请询问“要什么”，别告知“如何做”</h2><p>如下图， <code>Trip</code> 告知 <code>Mechanic</code> 如何去准备每一辆 bicycle.<br><img src="1.jpg" alt></p><p>下图里，<code>Trip</code> 要求 <code>Mechanic</code> 去准备每一个 bicycle</p><p><img src="2.jpg" alt></p><p>消息的这种变化是代码可维护性的一个巨大改进。因为它大大缩短了公共接口，大大减少出现“违背其承诺，然后强迫许多类进行更改”的情况。</p><h2 id="最小化上下文（context）"><a href="#最小化上下文（context）" class="headerlink" title="最小化上下文（context）"></a>最小化上下文（context）</h2><p>对象所了解到的关于其他对象的那些事情便构成了它的上下文。对象所期待的上下文会直接影响到它的重用难度。具有简单上下文的对象易于使用，也易于测试，他们对周边的环境期望很少。最好的情况是对象与他的上下文完全独立。如果某个对象在与其他对象进行合作时，不知道他们是谁，也不知道他们所做的事情，那么这个对象便可以按各种千奇百怪和完全无法预测的方式重用。</p><h2 id="信任其他对象"><a href="#信任其他对象" class="headerlink" title="信任其他对象"></a>信任其他对象</h2><p><code>我知道我需要什么，并且我相信你会做好你的本职工作。</code> 这种盲目的信任是面向对象设计的基石。在允许对象进行合作的同时，它无需将自己束缚在上下文里，并且在任何期望壮大和变化的应用程序里它都是必不可少的。</p><h2 id="创建显式接口"><a href="#创建显式接口" class="headerlink" title="创建显式接口"></a>创建显式接口</h2><ol><li>被明确标识；</li><li>多与 <code>做什么</code> 有关，少于 <code>怎么做</code> 有关；</li><li>尽可能让这些名字都稳定不变；</li><li>将散列表作为参数</li></ol><h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p>迪米特法则会限制可以向某个方法发送消息的对象集合。它会禁止这样的做法：将某条消息通过第二个不同类型的对象转发给第三个对象。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不合理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trip</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depart</span></span></span><br><span class="line">        customer.bicycle.wheel.tire</span><br><span class="line">        customer.bicycle.wheel.rotate</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># ......</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 合理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trip</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depart</span></span></span><br><span class="line">        customer.go</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># ......</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h2><p><code>Ducking Type</code> 指的是不会绑定到任何特定类的公共接口。这种跨类的接口能为应用程序带来巨大的灵活性，所采用的方式是利用更加宽容的消息依赖取代昂贵的类依赖。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 不好的写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trip</span></span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:bicycles</span>, <span class="symbol">:customers</span>, <span class="symbol">:vehicle</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prepare</span><span class="params">(preparers)</span></span></span><br><span class="line">        preparers.each &#123;<span class="params">|preparer|</span></span><br><span class="line">            <span class="keyword">case</span> preparer</span><br><span class="line">            <span class="keyword">when</span> Mechanic</span><br><span class="line">                preparer.prepare_bicycles(bicycles)</span><br><span class="line">            <span class="keyword">when</span> TripCoordinator</span><br><span class="line">                preparer.buy_food(customers)</span><br><span class="line">            <span class="keyword">when</span> Driver</span><br><span class="line">                preparer.gas_up(vehicle)</span><br><span class="line">                preparer.fill_water_tank(vehicle)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>删除依赖关系的关键是要意识到：<code>Trip</code>和<code>Prepare</code>方法只服务于单个目的，因此它的参数出现在这里是希望可以协作完成同一个目标。每一个参数都因同样的理由出现在这里，具体的原因与这些参数的底层类无关。<br>设计鸭子类型的挑战是：<strong>要注意到你需要一个鸭子类型，并且要将其接口抽象出来</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 好的写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trip</span></span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:bicycles</span>, <span class="symbol">:customers</span>, <span class="symbol">:vehicle</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prepare</span><span class="params">(preparers)</span></span></span><br><span class="line">        preparers.each &#123;<span class="params">|preparer|</span> preparer.prepare_trip(<span class="keyword">self</span>)&#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mechanic</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prepare_trip</span><span class="params">(trip)</span></span></span><br><span class="line">        trip.bicycles.each &#123;<span class="params">|bicycle|</span> prepare_bicycles(bicycle)&#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      How to create flexible interface and how to use ducking type
    
    </summary>
    
    
      <category term="Programming Language" scheme="https://zhangruochi.com/categories/Programming-Language/"/>
    
      <category term="Object Oriented Design" scheme="https://zhangruochi.com/categories/Programming-Language/Object-Oriented-Design/"/>
    
    
  </entry>
  
  <entry>
    <title>Dependency Management Principle</title>
    <link href="https://zhangruochi.com/Dependency-Management-Principle/2019/11/28/"/>
    <id>https://zhangruochi.com/Dependency-Management-Principle/2019/11/28/</id>
    <published>2019-11-28T19:49:09.000Z</published>
    <updated>2019-11-28T20:50:56.402Z</updated>
    
    <content type="html"><![CDATA[<p>通过精心设计的对象都具有单一的职责，因此他们实际上是通过<strong>合作</strong>来完成复杂的任务。这种合作强大而危险。为了实现一个合作，一个对象必须知道其他对象的某些情况。这种<strong>知道</strong>便创建了一种依赖关系。当两三个对象耦合在一起，它们变回表现得像一个整体，不可能只重用其中的一个。如果对依赖关系不仔细加以管理，那么这些依赖关系将毁掉整个应用程序。</p><p><img src="dependency.jpg" alt></p><h2 id="理解依赖关系"><a href="#理解依赖关系" class="headerlink" title="理解依赖关系"></a>理解依赖关系</h2><ol><li>知道另外一个类的名字<blockquote><p><code>Gear</code> 对 <code>Wheel</code> 的引用深入到 <code>gear_inches</code> 方法里，并将其硬编码，那么这便是明确说明它只愿意为 <code>Wheel.gear</code> 的实例计算齿轮英寸数，从而拒绝与其他任何类型的对象合作。</p></blockquote></li><li>消息的名字<blockquote><p><code>Gear</code> 需要访问可以相应 <code>diameter</code> 的对象。实际上，对 <code>Gear</code> 来说，计算 <code>gear_inches</code> 并不需要知道这个对象的类，只要这个对象可以相应 <code>diameter</code> 就行了。我们可以把这个对象理解成鸭子类型。</p></blockquote></li><li>消息所要求的参数<blockquote><p><code>Gear</code> 也并不需要知道 <code>Wheel</code> 需要使用 <code>rim</code> 和 <code>tire</code> 进行初始化</p></blockquote></li><li>参数的顺序<blockquote><p><code>Gear</code> 不需要知道 <code>Wheel</code> 初始化时参数的顺序</p></blockquote></li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gear</span></span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:chainring</span>, <span class="symbol">:cog</span>, <span class="symbol">:rim</span>, <span class="symbol">:tire</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(chainring,cog,rim,tire)</span></span></span><br><span class="line">        @chainring = chainring</span><br><span class="line">        @cog = cog</span><br><span class="line">        @rim = rim</span><br><span class="line">        @tire = tire</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ratio</span></span></span><br><span class="line">        chainring / cog.to_f   </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gear_inches</span></span></span><br><span class="line">        ratio * Wheel.new(rim,tire).diameter   <span class="comment"># &lt;---- 知道类的名字，知道消息的名字，知道参数，知道参数的顺序</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wheel</span></span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:rim</span>,<span class="symbol">:tire</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(rim,tire)</span></span></span><br><span class="line">        @rim = rim</span><br><span class="line">        @tire = tire</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diameter</span></span></span><br><span class="line">        rim + (tire * <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">circumference</span></span></span><br><span class="line">        diameter * Math::PI</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="隔离依赖关系"><a href="#隔离依赖关系" class="headerlink" title="隔离依赖关系"></a>隔离依赖关系</h2><h3 id="隔离实例的创建"><a href="#隔离实例的创建" class="headerlink" title="隔离实例的创建"></a>隔离实例的创建</h3><p>虽然此时 <code>Gear</code> 类仍然知道得太多，但是已经有所改进。如下的编码风格减少了 <code>gear_inches</code> 的依赖关系数量，同时公开暴露了 <code>Gear</code> 对 <code>Wheel</code> 的依赖。它们没有将依赖关系<strong>隐藏</strong>起来，而是将它们<strong>显露</strong>出来。这样降低了重用这段代码的门槛。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gear</span></span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:chainring</span>, <span class="symbol">:cog</span>, <span class="symbol">:rim</span>, <span class="symbol">:tire</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(chainring,cog,rim,tire)</span></span></span><br><span class="line">        @chainring = chainring</span><br><span class="line">        @cog = cog</span><br><span class="line">        @rim = rim</span><br><span class="line">        @tire = tire</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ratio</span></span></span><br><span class="line">        chainring / cog.to_f   </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gear_inches</span></span></span><br><span class="line">        ratio * wheel.diameter</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wheel</span>        <span class="comment">## &lt;--- 隔离实例的创建</span></span></span><br><span class="line">        @wheel <span class="params">||</span>= Wheel.new(rim,tire)   </span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="隔离外部消息"><a href="#隔离外部消息" class="headerlink" title="隔离外部消息"></a>隔离外部消息</h3><p>如下的编码方式，<code>wheel.diameter</code>被深度嵌套在 <code>gear_inches</code> 方法里。这个方法依赖 <code>Gear</code> 才能相应 Wheel，并且依赖<code>Wheel</code>才能响应diameter。完全没有必要在<code>gear_inches</code>里嵌入这种外部依赖，这使得 <code>Gear</code> 更加脆弱。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gear_inches</span></span></span><br><span class="line">    <span class="comment"># .... 假设存在额外的数学运算</span></span><br><span class="line">    ratio * wheel.diameter</span><br><span class="line">    <span class="comment"># .... 假设还存在额外的数学运算</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>现在我们将<code>wheel.gear</code>隔离在一个单独的方法里，并且 <code>gear_inches</code>可以依赖于某条发送给自己的消息。如果 <code>Wheel</code> 更改了<code>diameter</code>的名字或者签名，那么对<code>Gear</code>的副作用将会限定在一个简单的包裹方法里。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gear_inches</span></span></span><br><span class="line">    <span class="comment"># .... 假设存在额外的数学运算</span></span><br><span class="line">    ratio * diameter</span><br><span class="line">    <span class="comment"># .... 假设还存在额外的数学运算</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diameter</span></span></span><br><span class="line">    wheel.diameter</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="移除参数顺序依赖关系"><a href="#移除参数顺序依赖关系" class="headerlink" title="移除参数顺序依赖关系"></a>移除参数顺序依赖关系</h3><ol><li><p>使用散列表来进行初始化同时显示地指定默认值</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gear</span></span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:chainring</span>, <span class="symbol">:cog</span>, <span class="symbol">:wheel</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(args)</span></span></span><br><span class="line">        <span class="comment"># args = defaults.merge(args)</span></span><br><span class="line">        @chainring = args.fetch(<span class="symbol">:chainring</span>,<span class="number">40</span>)</span><br><span class="line">        @cog = args.fetch(<span class="symbol">:cog</span>,<span class="number">18</span>)</span><br><span class="line">        @wheel = args[<span class="symbol">:wheel</span>]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># def defaults</span></span><br><span class="line">    <span class="comment">#     &#123;:chainring =&gt; 40, :cog =&gt; 18&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># .......</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>隔离多参数初始化操作<br>有时候我们会被迫依赖某个要求参数初始化顺序的固定方法，由于那里不属于我们的地盘，我们无法更改这个方法。此时可以创建一个单一的方法，将外部接口包裹起来。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">SomeFramework</span></span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Gear</span></span></span><br><span class="line">        <span class="keyword">attr_reader</span> <span class="symbol">:chainring</span>, <span class="symbol">:cog</span>, <span class="symbol">:wheel</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(chainring,cog,wheel)</span></span></span><br><span class="line">            @chainring = chainring</span><br><span class="line">            @cog = cog</span><br><span class="line">            @wheel = wheel</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">ratio</span></span></span><br><span class="line">            chainring / cog.to_f   </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">gear_inches</span></span></span><br><span class="line">            ratio * wheel.diameter</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wheel</span></span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:rim</span>,<span class="symbol">:tire</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(rim,tire)</span></span></span><br><span class="line">        @rim = rim</span><br><span class="line">        @tire = tire</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diameter</span></span></span><br><span class="line">        rim + (tire * <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">circumference</span></span></span><br><span class="line">        diameter * Math::PI</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">GearWrapper</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">gear</span><span class="params">(args)</span></span></span><br><span class="line">        SomeFramework::Gear.new(args[<span class="symbol">:chainring</span>],args[<span class="symbol">:cog</span>],args[<span class="symbol">:wheel</span>])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p GearWrapper.gear(<span class="symbol">:chainring</span> =&gt; <span class="number">52</span>, <span class="symbol">:cog</span> =&gt; <span class="number">11</span>, <span class="symbol">:wheel</span> =&gt; Wheel.new(<span class="number">16</span>,<span class="number">1.5</span>)).gear_inches</span><br></pre></td></tr></table></figure></li><li><p>反转依赖关系</p></li></ol><ul><li>有些类比其他类更容易管理</li><li>具体类比抽象类更容易发生变化</li><li>更改拥有许多关系的类会造成广泛的变化<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gear</span></span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:chainring</span>, <span class="symbol">:cog</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(chainring,cog)</span></span></span><br><span class="line">        @chainring = chainring</span><br><span class="line">        @cog = cog</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ratio</span></span></span><br><span class="line">        chainring / cog.to_f   </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gear_inches</span><span class="params">(diameter)</span></span></span><br><span class="line">        ratio * diameter</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wheel</span></span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:rim</span>,<span class="symbol">:tire</span>, <span class="symbol">:gear</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(rim, tire, chainring, cog)</span></span></span><br><span class="line">        @rim = rim</span><br><span class="line">        @tire = tire</span><br><span class="line">        @gear = Gear.new(chainring, cog)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diameter</span></span></span><br><span class="line">        rim + (tire * <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gear_inches</span></span></span><br><span class="line">        gear.gear_inches diameter</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p Wheel.new(<span class="number">16</span>,<span class="number">1.5</span>, <span class="number">52</span>,<span class="number">11</span>).gear_inches</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      怎样管理程序中的依赖关系
    
    </summary>
    
    
      <category term="Programming Language" scheme="https://zhangruochi.com/categories/Programming-Language/"/>
    
      <category term="Object Oriented Design" scheme="https://zhangruochi.com/categories/Programming-Language/Object-Oriented-Design/"/>
    
    
  </entry>
  
  <entry>
    <title>Single Responsibility Principle</title>
    <link href="https://zhangruochi.com/Single-Responsibility-Principle/2019/11/27/"/>
    <id>https://zhangruochi.com/Single-Responsibility-Principle/2019/11/27/</id>
    <published>2019-11-27T21:50:20.000Z</published>
    <updated>2019-11-27T21:51:05.069Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">设计是保留可变性的艺术，而非达到完美性的行为</blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gear</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(chainring, cog, rim, tire)</span></span></span><br><span class="line">        @chainring = chainring</span><br><span class="line">        @cog = cog</span><br><span class="line">        @rim = rim</span><br><span class="line">        @tire = tire</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ratio</span></span></span><br><span class="line">        @chainring / @cog.to_f      <span class="comment"># &lt;------- 依赖数据</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gear_inches</span> </span></span><br><span class="line">        @ratio * (@rim + (@tire * <span class="number">2</span>))   <span class="comment"># &lt;------- 不符合单一职责，依赖数据</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">puts Gear.new(<span class="number">52</span>,<span class="number">11</span>,<span class="number">26</span>,<span class="number">1.5</span>).gear_inches</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObscuringReference</span></span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:data</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(data)</span></span></span><br><span class="line">        @data = data</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diameters</span></span></span><br><span class="line">        data.collect &#123;<span class="params">|cell|</span></span><br><span class="line">            cell[<span class="number">0</span>] + (cell[<span class="number">1</span>] * <span class="number">2</span>)   <span class="comment"># &lt;---- 依赖数据结构</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="如何确定单一职责"><a href="#如何确定单一职责" class="headerlink" title="如何确定单一职责"></a>如何确定单一职责</h2><ol><li>假设它存在意识，然后质询它<ul><li>齿轮先生，请问你的比率是多少？ ## 靠谱的询问</li><li>齿轮先生，请问你的轮胎尺寸是多少？## 荒唐可笑的询问</li></ul></li><li>尝试用一句话来描述类，如果出现 and 或者 or，则说明不遵循单一职责原则</li><li>高内聚(cohesion)<br>OO的设计者使用内聚来描述某个类的所有内容都与其<strong>中心目标</strong>相关联的情况。<strong>一个类有责任设计其目标。</strong></li></ol><h2 id="依赖行为，不要依赖数据"><a href="#依赖行为，不要依赖数据" class="headerlink" title="依赖行为，不要依赖数据"></a>依赖行为，不要依赖数据</h2><ol><li>实例变量被引用多次，如果需要进行调整，则需要大量重改。</li><li>将数据处理成行为，对行为的一次更改，可以作用在被引用的所有数据上。</li><li>隐藏数据结构<br>方法 diameters 不仅知道如何计算直径，他还知道在哪里找到钢圈(cell[0])和轮胎(cell[1]).</li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li><p>将数据结构的知识，封装在单一方法内部。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Wheel = Struct.new(<span class="symbol">:rim</span>,<span class="symbol">:tire</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wheelify</span><span class="params">(data)</span></span></span><br><span class="line">    data.collect &#123;</span><br><span class="line">        <span class="params">|cell|</span> Wheel.new(cell[<span class="number">0</span>],cell[<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diameters</span></span></span><br><span class="line">    wheels.collect &#123;<span class="params">|wheel|</span> wheel.rim * (wheel.tire * <span class="number">2</span>)&#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>将额外的责任从方法里提取出来</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diameters</span></span></span><br><span class="line">    wheels.collect &#123;<span class="params">|wheel|</span> diameter wheel&#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diameter</span><span class="params">(wheel)</span></span></span><br><span class="line">    wheel.rim + (wheel.tire * <span class="number">2</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gear_inches</span></span></span><br><span class="line">    ration * diameter</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>将类里的职责隔离<br>暂时缺乏足够的信息证明Wheel需要一个独立的类。有的时候，我们是否需要创建一个新的对象并不是有明确界限的。<strong>隔离起来总是不错的选择</strong>。同时要注意，不要讲无关的职责混入自己的类。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gear</span></span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:chainring</span>, <span class="symbol">:cog</span>, <span class="symbol">:wheel</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(chainring,cog,rim,tire)</span></span></span><br><span class="line">        @chainring = chainring</span><br><span class="line">        @cog = cog</span><br><span class="line">        @wheel = Wheel.new(rim,tire)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ratio</span></span></span><br><span class="line">        chainring / cog.to_f   </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gear_inches</span></span></span><br><span class="line">        ratio * wheel.diameter</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    Wheel = Struct.new(<span class="symbol">:rim</span>,<span class="symbol">:tire</span>) <span class="keyword">do</span>  <span class="comment"># &lt;----- 虽然Wheel存在于Gear里不算很好的选择，但是隔离Wheel的职责是不错的选择</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">diameter</span></span></span><br><span class="line">            rim + (tire * <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puts Gear.new(<span class="number">52</span>,<span class="number">11</span>,<span class="number">26</span>,<span class="number">1.5</span>).gear_inches</span><br></pre></td></tr></table></figure></li></ol><h2 id="需求的更改"><a href="#需求的更改" class="headerlink" title="需求的更改"></a>需求的更改</h2><p>如果此时，我们需要计算轮子的周长。<strong>这正是我们一直等待的信息，因为它提供了做下一步设计决定时所需要的信息。</strong> 注意敏捷开发里设计和代码迭代互相交互的原则。</p><p>现在我们有理由将Wheel独立成一个类了。因为我们将Wheel的职责隔离过，此时独立出它是很容易的。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gear</span></span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:chainring</span>, <span class="symbol">:cog</span>, <span class="symbol">:wheel</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(chainring,cog,wheel = <span class="literal">nil</span>)</span></span></span><br><span class="line">        @chainring = chainring</span><br><span class="line">        @cog = cog</span><br><span class="line">        @wheel = wheel</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ratio</span></span></span><br><span class="line">        chainring / cog.to_f   </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gear_inches</span></span></span><br><span class="line">        ratio * wheel.diameter</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wheel</span></span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:rim</span>,<span class="symbol">:tire</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(rim,tire)</span></span></span><br><span class="line">        @rim = rim</span><br><span class="line">        @tire = tire</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diameter</span></span></span><br><span class="line">        rim + (tire * <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">circumference</span></span></span><br><span class="line">        diameter * Math::PI</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">@wheel = Wheel.new(<span class="number">12</span>,<span class="number">1.5</span>)</span><br><span class="line">puts @wheel.circumference</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puts Gear.new(<span class="number">52</span>,<span class="number">11</span>,@wheel).gear_inches</span><br><span class="line">puts Gear.new(<span class="number">52</span>,<span class="number">11</span>).ratio</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      单一职责原则
    
    </summary>
    
    
      <category term="Programming Language" scheme="https://zhangruochi.com/categories/Programming-Language/"/>
    
      <category term="Object Oriented Design" scheme="https://zhangruochi.com/categories/Programming-Language/Object-Oriented-Design/"/>
    
    
  </entry>
  
  <entry>
    <title>Object Oriented Design</title>
    <link href="https://zhangruochi.com/Object-Oriented-Design/2019/11/27/"/>
    <id>https://zhangruochi.com/Object-Oriented-Design/2019/11/27/</id>
    <published>2019-11-27T06:32:23.000Z</published>
    <updated>2019-12-02T02:40:23.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>应用程序面对的最大的问题是将如何应对变化。将代码有效编排应对变化是设计的事情。最常见的设计要素是原则和模式。</p><h2 id="什么是面向对象设计"><a href="#什么是面向对象设计" class="headerlink" title="什么是面向对象设计"></a>什么是面向对象设计</h2><p>面向对象设计(OOD)认为世界是由多个对象以及对象之间的一系列消息传递构成的。</p><h2 id="设计赞歌"><a href="#设计赞歌" class="headerlink" title="设计赞歌"></a>设计赞歌</h2><h3 id="设计要解决的问题"><a href="#设计要解决的问题" class="headerlink" title="设计要解决的问题"></a>设计要解决的问题</h3><p>事情总是会发生变化，这是<strong>永恒不变</strong>的。客户并不知道他们自己想要什么，他们也说不清楚自己的意图。变化的需求是编程中的摩擦力与重力，这些力会作用到周密的设计上，从而形成出人意料的压力，这是这种意外的变化使得设计变得如此重要。因此，<strong>设计为了解决意外变化的问题</strong>。</p><h3 id="为何程序难以更改"><a href="#为何程序难以更改" class="headerlink" title="为何程序难以更改"></a>为何程序难以更改</h3><p>面向对象的应用程序由交互产生整体行为，对象是产生交互的零件，而交互则体现在他们之间传递的消息里。想要获得发送给正确目标的正确消息，需要消息的发送者对接受者有所了解。这一点会在两者之间创建许多依赖于联系，并且这些联系还在不断变化中。<br>面向对象设计与依赖关系管理相关，它是一套对依赖关系进行编排，以便各个对象能够容忍更改的编码技术。在缺乏设计的情形里，非托管的依赖关系很容易造成严重的破坏，因为这些对象互相之间了解太多，更改其中之一就会强制合作者也要随之发生变化。</p><h3 id="设计的定义"><a href="#设计的定义" class="headerlink" title="设计的定义"></a>设计的定义</h3><p>设计是一门艺术，一门编排代码的艺术。设计的工作具有高度的复杂性：需要对应用程序的需求有总体的理解，与各种设计原则的利与弊的知识组合起来，然后设计出当前算是成本最低，而在将来也能继续保持那个样子的代码编排。</p><h2 id="设计工具"><a href="#设计工具" class="headerlink" title="设计工具"></a>设计工具</h2><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ol><li>单一职责</li><li>开闭原则</li><li>里氏替换原则</li><li>接口隔离原则</li><li>依赖倒置原则</li><li>不重复原则</li></ol><p>优秀的设计原则代表的是可测量的真理，遵循它们能改善你的代码。</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>设计模式是在面向对象的软件设计过程中，<strong>针对特定问题的简单而优雅的解决方案</strong>。他是每位设计师的工具箱里的工具。</p><h2 id="设计行为"><a href="#设计行为" class="headerlink" title="设计行为"></a>设计行为</h2><h3 id="设计失败"><a href="#设计失败" class="headerlink" title="设计失败"></a>设计失败</h3><ol><li>缺乏设计知识</li><li>过度设计</li><li>设计与编程分开 </li></ol><h3 id="设计时机"><a href="#设计时机" class="headerlink" title="设计时机"></a>设计时机</h3><p>敏捷开发方法相信，大规模预先设计是完全没有意义的，因为它不可能正确。也没有人知道什么时候应用程序会完成。用户在看到具体的软件之前，对所想要的软件是没有概念的，所以向他们展示软件的时机宜早不宜迟。基于这个逻辑，我们的程序应该以<strong>微增量</strong>的方式来构建软件，逐步将你的方法迭代成满足客户真正需求的应用程序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h2&gt;&lt;p&gt;应用程序面对的最大的问题是将如何应对变化。将代码有效编排应对变化是设计的事情。最常见的设计要素是原则和模式。&lt;/p&gt;
&lt;h2 id=&quot;什么是
      
    
    </summary>
    
    
      <category term="Programming Language" scheme="https://zhangruochi.com/categories/Programming-Language/"/>
    
      <category term="Object Oriented Design" scheme="https://zhangruochi.com/categories/Programming-Language/Object-Oriented-Design/"/>
    
    
  </entry>
  
  <entry>
    <title>Basic Calculator</title>
    <link href="https://zhangruochi.com/Basic-Calculator/2019/11/26/"/>
    <id>https://zhangruochi.com/Basic-Calculator/2019/11/26/</id>
    <published>2019-11-26T21:56:37.000Z</published>
    <updated>2019-11-26T22:12:47.372Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-224-Basic-Calculator"><a href="#Leetcode-224-Basic-Calculator" class="headerlink" title="Leetcode 224. Basic Calculator"></a>Leetcode 224. <a href="https://leetcode.com/problems/basic-calculator/" target="_blank" rel="noopener">Basic Calculator</a></h2><p><img src="tree.png" alt></p><h3 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h3><p>中缀表达式是一种通用的算术或逻辑公式表示方法，操作符以中缀形式处于操作数的中间。中缀表达式是人们常用的算术表示方法，它是由相应的语法树的中序遍历的结果得到的。</p><blockquote><p>A + B * ( C - D ) - E * F</p></blockquote><h3 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h3><p>首先要知道什么是后缀表达式，后缀表达式又叫做逆波兰式吗它是由相应的语法树的后序遍历的结果得到的。如下图的后缀表达式为： </p><blockquote><p>A B C D - * + E F * -</p></blockquote><h3 id="中缀表达式转化为后缀表达式"><a href="#中缀表达式转化为后缀表达式" class="headerlink" title="中缀表达式转化为后缀表达式"></a>中缀表达式转化为后缀表达式</h3><ol><li>从左到右遍历中缀表达式的每个数字和符号;</li><li>若是数字就输出，即成为后缀表达式的一部分;</li><li>若是符号：<ol><li>如果是左括号，入栈；</li><li>如果是右括号，输出栈顶元素直到左括号为止，括号不输出；</li><li>如果不是括号，判断其与栈顶符号的优先级，优先级<strong>低于</strong>栈顶符号（乘除优先加减），则栈顶元素依次出栈并输出，并将当前符号进栈。优先级<strong>高于</strong>栈顶符号，入栈。</li></ol></li></ol><h3 id="根据后缀表达式计算算式的值"><a href="#根据后缀表达式计算算式的值" class="headerlink" title="根据后缀表达式计算算式的值"></a>根据后缀表达式计算算式的值</h3><ol><li>维护一个栈，遍历后缀表达式</li><li>遇到数字入栈</li><li>遇到操作符，弹出两个栈顶元素，计算结果，将结果入栈</li><li>最后栈顶元素即为所求 </li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    opr = &#123;<span class="string">"+"</span>:<span class="number">0</span>,<span class="string">"-"</span>:<span class="number">0</span>,<span class="string">"*"</span>:<span class="number">1</span>,<span class="string">"/"</span>:<span class="number">1</span>,<span class="string">"("</span>: <span class="number">-1</span>,<span class="string">")"</span>: <span class="number">-1</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_postfix</span><span class="params">(self,s)</span>:</span></span><br><span class="line">        </span><br><span class="line">        stack = []</span><br><span class="line">        res = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">" "</span>:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] <span class="keyword">not</span> <span class="keyword">in</span> self.opr:</span><br><span class="line">                num = <span class="string">""</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; len(s) <span class="keyword">and</span> s[i] <span class="keyword">not</span> <span class="keyword">in</span> self.opr:</span><br><span class="line">                    num += s[i]</span><br><span class="line">                    i+=<span class="number">1</span></span><br><span class="line">                res.append(int(num))</span><br><span class="line">                num =<span class="string">""</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> s[i] == <span class="string">"("</span>:</span><br><span class="line">                    stack.append(s[i])</span><br><span class="line">                <span class="keyword">elif</span> s[i] == <span class="string">")"</span>:</span><br><span class="line">                    <span class="keyword">while</span> stack[<span class="number">-1</span>] != <span class="string">"("</span>:</span><br><span class="line">                        op = stack.pop()</span><br><span class="line">                        res += op</span><br><span class="line">                    stack.pop()</span><br><span class="line">                <span class="keyword">elif</span> (<span class="keyword">not</span> stack) <span class="keyword">or</span> self.opr[stack[<span class="number">-1</span>]] &lt; self.opr[s[i]]: <span class="comment">## 栈顶操作符优先级低，直接入栈</span></span><br><span class="line">                    stack.append(s[i])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment">## 栈顶操作符优先级大于等于当前操作符，一直弹出，直到栈顶元素的优先级小于当前元素为止</span></span><br><span class="line">                    <span class="keyword">while</span> stack <span class="keyword">and</span> self.opr[stack[<span class="number">-1</span>]] &gt;= self.opr[s[i]]:</span><br><span class="line">                        op = stack.pop()</span><br><span class="line">                        res += op</span><br><span class="line">                    stack.append(s[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            res += stack.pop()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate_postfix</span><span class="params">(self,s)</span>:</span></span><br><span class="line"></span><br><span class="line">        print(s)</span><br><span class="line"></span><br><span class="line">        add = <span class="keyword">lambda</span> x,y: x+y</span><br><span class="line">        sub = <span class="keyword">lambda</span> x,y: x-y</span><br><span class="line">        mul = <span class="keyword">lambda</span> x,y: x*y</span><br><span class="line">        div = <span class="keyword">lambda</span> x,y: x//y</span><br><span class="line"></span><br><span class="line">        self.opr_func = &#123;<span class="string">"+"</span>:add,<span class="string">"-"</span>:sub,<span class="string">"*"</span>:mul,<span class="string">"/"</span>:div&#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> self.opr:</span><br><span class="line">                stack.append(int(char))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                second = stack.pop()</span><br><span class="line">                first = stack.pop()</span><br><span class="line">                stack.append(self.opr_func[char](first,second))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack[<span class="number">-1</span>]</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.calculate_postfix(self.to_postfix(s))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Calculator design
    
    </summary>
    
    
      <category term="Data Structure and Algorithm" scheme="https://zhangruochi.com/categories/Data-Structure-and-Algorithm/"/>
    
    
      <category term="Project" scheme="https://zhangruochi.com/tags/Project/"/>
    
      <category term="Leetcode" scheme="https://zhangruochi.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Longest common subsequence &amp; subarray &amp; substring</title>
    <link href="https://zhangruochi.com/Longest-common-subsequence-subarray-substring/2019/11/26/"/>
    <id>https://zhangruochi.com/Longest-common-subsequence-subarray-substring/2019/11/26/</id>
    <published>2019-11-26T07:27:02.000Z</published>
    <updated>2019-11-26T22:12:28.910Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-718-Maximum-Length-of-Repeated-Subarray"><a href="#LeetCode-718-Maximum-Length-of-Repeated-Subarray" class="headerlink" title="LeetCode 718. Maximum Length of Repeated Subarray"></a>LeetCode 718. <a href="https://leetcode.com/problems/maximum-length-of-repeated-subarray/" target="_blank" rel="noopener">Maximum Length of Repeated Subarray</a></h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Given two <span class="built_in">integer</span> arrays A and B, <span class="built_in">return</span> the maximum length of an subarray that appears <span class="keyword">in</span> both arrays.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">A: [1,2,3,2,1]</span><br><span class="line">B: [3,2,1,4,7]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">The repeated subarray with maximum length is [3, 2, 1].</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">1 &lt;= len(A), len(B) &lt;= 1000</span><br><span class="line">0 &lt;= A[i], B[i] &lt; 100</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题给了我们两个数组A和B，让返回连个数组的最长重复子数组。那么如果将数组换成字符串，实际这道题就是求 Longest Common Substring 的问题了。<strong>注意需要跟最长子序列 Longest Common Subsequence 区分开</strong>。 既然是子数组，那么重复的地方一定是连续的。对于这种求极值的问题，动态规划 Dynamic Programming 一直都是一个很好的选择，这里使用一个二维的 DP 数组，其中 dp[i][j] 表示数组A的前i个数字和数组B的前j个数字的最长子数组的长度，如果 dp[i][j] 不为0，则A中第i个数组和B中第j个数字必须相等，比对于这两个数组 [1,2,2] 和 [3,1,2]，dp 数组为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  3 1 2</span><br><span class="line">1 0 1 0</span><br><span class="line">2 0 0 2</span><br><span class="line">2 0 0 1</span><br></pre></td></tr></table></figure><ul><li>dp[i][j] := max length of (A[0:i], B[0:j])</li><li>dp[i][j] = dp[i – 1][j – 1] + 1 if A[i-1] == B[j-1] else 0</li><li>Time complexity: O(m*n)</li><li>Space complexity: O(m*n) -&gt; O(n)</li></ul><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLength</span><span class="params">(self, A: List[int], B: List[int])</span> -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># A --&gt; j</span></span><br><span class="line">        <span class="comment"># B --&gt; i</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A <span class="keyword">or</span> <span class="keyword">not</span> B:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="number">0</span>]*len(A) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(B))]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            <span class="keyword">if</span> A[j] == B[<span class="number">0</span>]:</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">                res = max(res,dp[<span class="number">0</span>][j])</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(B)):</span><br><span class="line">            <span class="keyword">if</span> B[i] == A[<span class="number">0</span>]:</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">                res = max(res,dp[i][<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(A)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,len(B)):</span><br><span class="line">                <span class="keyword">if</span> B[i] == A[j]:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">                    res = max(res,dp[i][j])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="Leetoce-1143-Longest-Common-Subsequence"><a href="#Leetoce-1143-Longest-Common-Subsequence" class="headerlink" title="Leetoce 1143. Longest Common Subsequence"></a>Leetoce 1143. <a href="https://leetcode.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">Longest Common Subsequence</a></h2><blockquote><p>A subsequence of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, “ace” is a subsequence of “abcde” while “aec” is not). A common subsequence of two strings is a subsequence that is common to both strings.</p></blockquote><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Given two strings text1 and text2, <span class="built_in">return</span> the length of their longest common subsequence.</span><br><span class="line"></span><br><span class="line">A subsequence of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, <span class="string">"ace"</span> is a subsequence of <span class="string">"abcde"</span> <span class="keyword">while</span> <span class="string">"aec"</span> is not). A common subsequence of two strings is a subsequence that is common to both strings.</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">If there is no common subsequence, <span class="built_in">return</span> 0.</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: text1 = <span class="string">"abcde"</span>, text2 = <span class="string">"ace"</span> </span><br><span class="line">Output: 3  </span><br><span class="line">Explanation: The longest common subsequence is <span class="string">"ace"</span> and its length is 3.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: text1 = <span class="string">"abc"</span>, text2 = <span class="string">"abc"</span></span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest common subsequence is <span class="string">"abc"</span> and its length is 3.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: text1 = <span class="string">"abc"</span>, text2 = <span class="string">"def"</span></span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no such common subsequence, so the result is 0.</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line"></span><br><span class="line">1 &lt;= text1.length &lt;= 1000</span><br><span class="line">1 &lt;= text2.length &lt;= 1000</span><br><span class="line">The input strings consist of lowercase English characters only.</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>dp[i][j] stands for length of LCS between text1 up to i and text2 up to j.</li><li>dp[i][j] = dp[i-1][j-1] + 1 if text1[i] == text2[j] </li><li>Otherwise, dp[i][j] = max(dp[i][j-1], dp[i-1][j])</li></ul><h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span><span class="params">(self, text1: str, text2: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> text1 <span class="keyword">or</span> <span class="keyword">not</span> text2:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="number">0</span>] * len(text1) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(text2))]</span><br><span class="line">        <span class="comment">## text1 --&gt;j; text2--&gt;i</span></span><br><span class="line">        </span><br><span class="line">        flag = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(text2)):</span><br><span class="line">            <span class="keyword">if</span> text2[i] == text1[<span class="number">0</span>]:</span><br><span class="line">                flag = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        flag = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(text1)):</span><br><span class="line">            <span class="keyword">if</span> text1[j] == text2[<span class="number">0</span>]:</span><br><span class="line">                flag = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(text2)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,len(text1)):</span><br><span class="line">                <span class="keyword">if</span> text2[i] == text1[j]:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[i][j]</span><br></pre></td></tr></table></figure><h2 id="Leetoce-583-Delete-Operation-for-Two-Strings"><a href="#Leetoce-583-Delete-Operation-for-Two-Strings" class="headerlink" title="Leetoce 583. Delete Operation for Two Strings"></a>Leetoce 583. <a href="https://leetcode.com/problems/delete-operation-for-two-strings/" target="_blank" rel="noopener">Delete Operation for Two Strings</a></h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Given two words word1 and word2, find the minimum number of steps required to make word1 and word2 the same, <span class="built_in">where</span> <span class="keyword">in</span> each step you can delete one character <span class="keyword">in</span> either string.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: <span class="string">"sea"</span>, <span class="string">"eat"</span></span><br><span class="line">Output: 2</span><br><span class="line">Explanation: You need one step to make <span class="string">"sea"</span> to <span class="string">"ea"</span> and another step to make <span class="string">"eat"</span> to <span class="string">"ea"</span>.</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">The length of given words won<span class="string">'t exceed 500.</span></span><br><span class="line"><span class="string">Characters in given words can only be lower-case letters.</span></span><br></pre></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>这题实际上是求两个字符串的 Longest Common Subsequence. 然后用两个字符串的长度和减去 2*LCS. DP的思路与上题一样。</p><h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> word1 <span class="keyword">or</span> <span class="keyword">not</span> word2:</span><br><span class="line">            same = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp = [[<span class="number">0</span>] * len(word1) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word2))]</span><br><span class="line">            <span class="comment">## text1 --&gt;j; text2--&gt;i</span></span><br><span class="line"></span><br><span class="line">            flag = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word2)):</span><br><span class="line">                <span class="keyword">if</span> word2[i] == word1[<span class="number">0</span>]:</span><br><span class="line">                    flag = <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">if</span> flag:</span><br><span class="line">                    dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            flag = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(word1)):</span><br><span class="line">                <span class="keyword">if</span> word1[j] == word2[<span class="number">0</span>]:</span><br><span class="line">                    flag = <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">if</span> flag:</span><br><span class="line">                    dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(word2)):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,len(word1)):</span><br><span class="line">                    <span class="keyword">if</span> word2[i] == word1[j]:</span><br><span class="line">                        dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">            same = dp[i][j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> len(word1) + len(word2) - same*<span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="Leetcode-1092-Shortest-Common-Supersequence"><a href="#Leetcode-1092-Shortest-Common-Supersequence" class="headerlink" title="Leetcode 1092. Shortest Common Supersequence"></a>Leetcode 1092. <a href="https://leetcode.com/problems/shortest-common-supersequence/" target="_blank" rel="noopener">Shortest Common Supersequence</a></h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Given two strings str1 and str2, <span class="built_in">return</span> the shortest string that has both str1 and str2 as subsequences.  If multiple answers exist, you may <span class="built_in">return</span> any of them.</span><br><span class="line"></span><br><span class="line">(A string S is a subsequence of string T <span class="keyword">if</span> deleting some number of characters from T (possibly 0, and the characters are chosen anywhere from T) results <span class="keyword">in</span> the string S.)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: str1 = <span class="string">"abac"</span>, str2 = <span class="string">"cab"</span></span><br><span class="line">Output: <span class="string">"cabac"</span></span><br><span class="line">Explanation: </span><br><span class="line">str1 = <span class="string">"abac"</span> is a subsequence of <span class="string">"cabac"</span> because we can delete the first <span class="string">"c"</span>.</span><br><span class="line">str2 = <span class="string">"cab"</span> is a subsequence of <span class="string">"cabac"</span> because we can delete the last <span class="string">"ac"</span>.</span><br><span class="line">The answer provided is the shortest such string that satisfies these properties.</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">1 &lt;= str1.length, str2.length &lt;= 1000</span><br><span class="line">str1 and str2 consist of lowercase English letters.</span><br></pre></td></tr></table></figure><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p><img src="lcs.png" alt></p><h3 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h3><pre><code class="lang-python">class Solution:    def shortestCommonSupersequence(self, str1: str, str2: str) -&gt; str:        if not str1 or not str2:            return &quot;&quot;        dp = [[0] * (len(str2)+1) for i in range(len(str1)+1)]        # dp[i][j] --&gt;  i: str1, j: str2        for i in range(1,len(str1)+1):            for j in range(1,len(str2)+1):                if str1[i-1] == str2[j-1]:                    dp[i][j] = dp[i-1][j-1] + 1                else:                    dp[i][j] = max(dp[i-1][j],dp[i][j-1])        l1 = len(str1); l2 = len(str2)        res = []        while l1 or l2:            if not l1:                char = str2[l2-1]                l2 -= 1            elif not l2:                char = str1[l1-1]                l1 -= 1            elif str1[l1-1] == str2[l2-1]:                char = str1[l1-1]                l1 -= 1                l2 -= 1            elif dp[l1-1][l2] == dp[l1][l2]:                char = str1[l1-1]                l1 -= 1            elif dp[l1][l2-1] == dp[l1][l2]:                char = str2[l2-1]                l2 -= 1            res.append(char)        return &quot;&quot;.join(res[::-1])</code></pre><blockquote><p>reference from <a href="https://zxi.mytechroad.com/blog/dynamic-programming/leetcode-1092-shortest-common-supersequence/" target="_blank" rel="noopener">https://zxi.mytechroad.com/blog/dynamic-programming/leetcode-1092-shortest-common-supersequence/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      the summary of Longest common subsequence subarray substring base on leetcode questions
    
    </summary>
    
    
      <category term="Data Structure and Algorithm" scheme="https://zhangruochi.com/categories/Data-Structure-and-Algorithm/"/>
    
    
      <category term="Leetcode" scheme="https://zhangruochi.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Ruby Hightlights</title>
    <link href="https://zhangruochi.com/Ruby-Hightlights/2019/11/24/"/>
    <id>https://zhangruochi.com/Ruby-Hightlights/2019/11/24/</id>
    <published>2019-11-25T01:11:56.000Z</published>
    <updated>2019-11-25T20:14:53.587Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><div class="table-container"><table><thead><tr><th style="text-align:left">标识符</th><th style="text-align:left">例子</th></tr></thead><tbody><tr><td style="text-align:left">局部变量</td><td style="text-align:left">first_name</td></tr><tr><td style="text-align:left">实例变量</td><td style="text-align:left">@first_name</td></tr><tr><td style="text-align:left">类变量</td><td style="text-align:left">@@first_name</td></tr><tr><td style="text-align:left">全局变量</td><td style="text-align:left">$FIRST_NAME</td></tr><tr><td style="text-align:left">常量</td><td style="text-align:left">FIRST_NAME</td></tr><tr><td style="text-align:left">关键字</td><td style="text-align:left">class</td></tr><tr><td style="text-align:left">方法名</td><td style="text-align:left">同局部变量</td></tr></tbody></table></div><h3 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h3><p>类变量的作用域并不属于类作用域，而是输入类层级的作用域。它提供了一种可以在类和类的实例之间共享数据的存储机制，但是对其他对象不可见。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line">    @@makes = []</span><br><span class="line">    @@cars = &#123;&#125;</span><br><span class="line">    @@total_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:make</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">add_make</span><span class="params">(make)</span></span></span><br><span class="line">        <span class="keyword">unless</span> @@makes.<span class="keyword">include</span>?(make)</span><br><span class="line">            @@makes &lt;&lt; make</span><br><span class="line">            @@cars[make] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">total_count</span></span></span><br><span class="line">        puts <span class="string">"<span class="subst">#&#123;@@total_count&#125;</span>"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(make)</span></span></span><br><span class="line">        <span class="keyword">if</span> @@makes.<span class="keyword">include</span>? make</span><br><span class="line">            puts <span class="string">"Create a new make <span class="subst">#&#123;make&#125;</span>"</span></span><br><span class="line">            @make = make</span><br><span class="line">            @@cars[make] += <span class="number">1</span></span><br><span class="line">            @@total_count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            raise <span class="string">"no such make"</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_mates</span></span></span><br><span class="line">        @@cars[<span class="keyword">self</span>.make]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_count</span></span></span><br><span class="line">        puts <span class="string">"<span class="subst">#&#123;@@total_count&#125;</span>"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># my_car = Car.new "xx"</span></span><br><span class="line">Car.add_make(<span class="string">"BMW"</span>)</span><br><span class="line">my_car = Car.new <span class="string">"BMW"</span></span><br><span class="line">Car.total_count</span><br><span class="line">puts my_car.make</span><br><span class="line">my_car.total_count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">=begin</span></span><br><span class="line"><span class="comment">Create a new make BMW</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">BMW</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">=end</span></span><br></pre></td></tr></table></figure></p><h3 id="父类和子类共享类变量"><a href="#父类和子类共享类变量" class="headerlink" title="父类和子类共享类变量"></a>父类和子类共享类变量</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span></span><br><span class="line">    @@value = <span class="number">100</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> &lt; Parent</span></span><br><span class="line">    @@value = <span class="number">200</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span></span><br><span class="line">    puts @@value</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Parent.new <span class="comment"># 200</span></span><br></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>定义在类中的实例方法可以看到同样定义在类中的常量，但其他程序也可以看到这些常量</p><h3 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h3><p>私有方法不能显式地被接收者调用。因为当没有明确接收对象时，接收对象是self。所以如果接收对象是Test的一个实例时，是可以调用成功的。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">a</span></span></span><br><span class="line">        puts <span class="string">"a"</span> </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">b</span></span></span><br><span class="line">        <span class="comment"># self.a error</span></span><br><span class="line">        a</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    private <span class="symbol">:a</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">test = Test.new</span><br><span class="line">test.a <span class="comment"># error!</span></span><br><span class="line">test.b <span class="comment"># "a"</span></span><br></pre></td></tr></table></figure></p><h3 id="保护方法"><a href="#保护方法" class="headerlink" title="保护方法"></a>保护方法</h3><p>只能在此对象的实例方法或此类(或子类)的另一个对象中直接调用受保护的方法。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">a</span></span></span><br><span class="line">        puts <span class="string">"a"</span> </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">b</span></span></span><br><span class="line">        a</span><br><span class="line">        puts <span class="string">"<span class="subst">#&#123;<span class="keyword">self</span>&#125;</span>"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    protected <span class="symbol">:a</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">test = Test.new</span><br><span class="line">test.b</span><br></pre></td></tr></table></figure><h2 id="Class-and-object"><a href="#Class-and-object" class="headerlink" title="Class and object"></a>Class and object</h2><h3 id="查看对象的原生方法"><a href="#查看对象的原生方法" class="headerlink" title="查看对象的原生方法"></a>查看对象的原生方法</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p Object.new.methods.sort</span><br><span class="line"><span class="comment">=begin</span></span><br><span class="line"><span class="comment">[:!, :!=, :!~, :&lt;=&gt;, :==, :===, :=~, :__id__, :__send__, :class, :clone, :define_singleton_method, :display, :dup, :enum_for, :eql?, :equal?, :extend, :freeze, :frozen?, :hash, :inspect, :instance_eval, :instance_exec, :instance_of?, :instance_variable_defined?, :instance_variable_get, :instance_variable_set, :instance_variables, :is_a?, :itself, :kind_of?, :method, :methods, :nil?, :object_id, :private_methods, :protected_methods, :public_method, :public_methods, :public_send, :remove_instance_variable, :respond_to?, :send, :singleton_class, :singleton_method, :singleton_methods, :taint, :tainted?, :tap, :then, :to_enum, :to_s, :trust, :untaint, :untrust, :untrusted?, :yield_self]</span></span><br><span class="line"><span class="comment">=end</span></span><br></pre></td></tr></table></figure><h3 id="重开类"><a href="#重开类" class="headerlink" title="重开类"></a>重开类</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">m</span></span></span><br><span class="line">        puts <span class="string">"method m"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">y</span></span></span><br><span class="line">        puts <span class="string">"methods y"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p C.new.methods.sort</span><br><span class="line"></span><br><span class="line"><span class="comment"># [...... :m, ...... :y, ......]</span></span><br></pre></td></tr></table></figure><h3 id="单例方法"><a href="#单例方法" class="headerlink" title="单例方法"></a>单例方法</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">obj = Object.new</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">obj</span>.<span class="title">test</span></span></span><br><span class="line">    p <span class="string">"test"</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">cla = Class.new</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cla</span>.<span class="title">test</span></span></span><br><span class="line">    p <span class="string">"test"</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj.test</span><br><span class="line">cla.test</span><br><span class="line"></span><br><span class="line"><span class="comment"># "test"</span></span><br><span class="line"><span class="comment"># "test"</span></span><br></pre></td></tr></table></figure><h3 id="对象方法查找规则"><a href="#对象方法查找规则" class="headerlink" title="对象方法查找规则"></a>对象方法查找规则</h3><p><img src="methods.jpg" alt></p><h3 id="类对象怎样查找方法"><a href="#类对象怎样查找方法" class="headerlink" title="类对象怎样查找方法"></a>类对象怎样查找方法</h3><ul><li>类是对象</li><li>类的实例也是对象</li><li>类对象有自己的方法、自己的状态和唯一标识</li></ul><p>因此，类的对象方法查找规则是</p><ol><li>从他的类</li><li>从超类和他们类更早的祖先</li><li>从存储在他们自身的单例方法</li></ol><h3 id="顶层方法"><a href="#顶层方法" class="headerlink" title="顶层方法"></a>顶层方法</h3><p>顶层方法作为Object类的私有方法被保存下来，它在任何地方可用，但是不能现式地指定接收者。</p><h2 id="Self"><a href="#Self" class="headerlink" title="Self"></a>Self</h2><p><img src="self.jpg" alt></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">puts <span class="string">"In top level, self is:  <span class="subst">#&#123;<span class="keyword">self</span>&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">A</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">n</span></span></span><br><span class="line">        puts <span class="string">"In module A, self is:  <span class="subst">#&#123;<span class="keyword">self</span>&#125;</span>"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line">    puts <span class="string">"In Test, self is: <span class="subst">#&#123;<span class="keyword">self</span>&#125;</span>"</span>  <span class="comment"># 类对象</span></span><br><span class="line">    <span class="keyword">include</span> A</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">x</span></span></span><br><span class="line">        puts <span class="string">"In x, self is: <span class="subst">#&#123;<span class="keyword">self</span>&#125;</span>"</span>   <span class="comment"># 类对象</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">m</span></span></span><br><span class="line">        puts <span class="string">"In m, self is: <span class="subst">#&#123;<span class="keyword">self</span>&#125;</span>"</span>  <span class="comment"># 实例对象</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">test = Test.new</span><br><span class="line">Test.x</span><br><span class="line">test.m</span><br><span class="line">test.n</span><br><span class="line"></span><br><span class="line"><span class="comment">=begin</span></span><br><span class="line"><span class="comment">In top level, self is:  main</span></span><br><span class="line"><span class="comment">In Test, self is: Test</span></span><br><span class="line"><span class="comment">In x, self is: Test</span></span><br><span class="line"><span class="comment">In m, self is: #&lt;Test:0x00007fa01a04cbc8&gt;</span></span><br><span class="line"><span class="comment">In module A, self is:  #&lt;Test:0x00007fa01a04cbc8&gt;</span></span><br><span class="line"><span class="comment">=end</span></span><br></pre></td></tr></table></figure><h2 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h2><p><img src="scope.jpg" alt></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">t</span></span></span><br><span class="line">    puts <span class="string">"Top level method t"</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">x</span></span></span><br><span class="line">        a = <span class="number">2</span></span><br><span class="line">        puts <span class="string">"C.x, a = <span class="subst">#&#123;a&#125;</span>"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">m</span></span></span><br><span class="line">        a = <span class="number">3</span></span><br><span class="line">        puts <span class="string">"C#m; a = <span class="subst">#&#123;a&#125;</span>"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">n</span></span></span><br><span class="line">        a = <span class="number">4</span></span><br><span class="line">        puts <span class="string">"C#n; a = <span class="subst">#&#123;a&#125;</span>"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    puts <span class="string">"class scope: a = <span class="subst">#&#123;a&#125;</span>"</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C.x</span><br><span class="line">c = C.new</span><br><span class="line">c.m</span><br><span class="line">c.n</span><br><span class="line"></span><br><span class="line"><span class="comment">=begin</span></span><br><span class="line"><span class="comment">class scope: a = 1</span></span><br><span class="line"><span class="comment">C.x, a = 2</span></span><br><span class="line"><span class="comment">C#m; a = 3</span></span><br><span class="line"><span class="comment">C#n; a = 4</span></span><br><span class="line"><span class="comment">=end</span></span><br></pre></td></tr></table></figure><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="case-子句"><a href="#case-子句" class="headerlink" title="case 子句"></a>case 子句</h3><p>每个 ruby 对象都有一个 case 相等性判断方法: <strong>===</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line">    <span class="keyword">attr_accessor</span> <span class="symbol">:age</span>, <span class="symbol">:height</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(age,height)</span></span></span><br><span class="line">        <span class="keyword">self</span>.age = age</span><br><span class="line">        <span class="keyword">self</span>.height = height</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">===</span><span class="params">(other_obj)</span></span></span><br><span class="line">        (<span class="keyword">self</span>.age == other_obj.age) &amp; (<span class="keyword">self</span>.height == other_obj.height)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$person1 = Person.new(<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line">$person2 = Person.new(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(person)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> person</span><br><span class="line">    <span class="keyword">when</span> $person1</span><br><span class="line">        puts <span class="string">"person 1"</span></span><br><span class="line">    <span class="keyword">when</span> $person2</span><br><span class="line">        puts <span class="string">"person"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        puts <span class="string">"not matching"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">person = Person.new(<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line">test(person) <span class="comment"># person 1</span></span><br></pre></td></tr></table></figure><h3 id="比较和-Comparable-模块"><a href="#比较和-Comparable-模块" class="headerlink" title="比较和 Comparable 模块"></a>比较和 Comparable 模块</h3><p>如果类需要有完整的比较方法，可以由如下解决方案：</p><ul><li>混合名为 Comparable 的模块</li><li>定义 <strong>&lt;=&gt;</strong> 的比较方法做为实例方法，在这个方法内部需要定义”小于”，”等于”，”大于”的含义。</li></ul><h3 id="代码块（block-和-关键字-yield"><a href="#代码块（block-和-关键字-yield" class="headerlink" title="代码块（block) 和 关键字 (yield)"></a>代码块（block) 和 关键字 (yield)</h3><p>ruby 中的每个方法调用都遵循如下语法：</p><ol><li>接收者对象或者变量</li><li>点（如果有明确的接收者则为必要条件）</li><li>方法名</li><li>参数列表（可选，默认为（））</li><li>代码块 （可选，没有默认）</li></ol><ul><li>代码块可以使用 {}, 也可以使用 do while 提供；</li><li>如果提供的代码块在方法中不能提供，并不会发生错误；</li><li>代码块和方法一样，可以接受参数；</li><li>yeild 的实际总用是转移控制权与作用域到代码块（可以跳回来）。</li><li>代码块是一个闭包(closure)</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">block_scope</span></span></span><br><span class="line">    x = <span class="number">10</span></span><br><span class="line">    <span class="number">1</span>.times &#123; puts x&#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">block_scope <span class="comment"># 10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">block_scope</span></span></span><br><span class="line">    x = <span class="number">10</span></span><br><span class="line">    <span class="number">1</span>.times <span class="keyword">do</span></span><br><span class="line">        x = <span class="number">20</span></span><br><span class="line">        puts x</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">block_scope <span class="comment"># 20</span></span><br></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ol><li><p>here-doc</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">text = &lt;&lt;EOM.to_i</span><br><span class="line"><span class="number">10</span></span><br><span class="line">EOM</span><br><span class="line"></span><br><span class="line">puts text <span class="comment"># 10</span></span><br></pre></td></tr></table></figure></li><li><p>索引</p></li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string = <span class="string">"zhangruochi"</span></span><br><span class="line"></span><br><span class="line">puts string[<span class="number">0</span>,<span class="number">2</span>] <span class="comment"># zh</span></span><br><span class="line">puts string[<span class="number">0</span>..<span class="number">2</span>] <span class="comment"># zha</span></span><br><span class="line">puts string[<span class="number">0</span>...<span class="number">2</span>] <span class="comment"># zh</span></span><br><span class="line">puts string[<span class="number">0</span>..-<span class="number">1</span>] <span class="comment"># zhangruochi</span></span><br><span class="line">puts string[<span class="string">"zhang"</span>] <span class="comment">#zhang</span></span><br><span class="line">puts string[<span class="string">"xxx"</span>] <span class="comment">#nil</span></span><br></pre></td></tr></table></figure><h2 id="Enumerable"><a href="#Enumerable" class="headerlink" title="Enumerable"></a>Enumerable</h2><p>在ruby中，对象之间共有的特性通常都被放在模块里，集合类型也不例外：Ruby中的集合类型对象通常都包含 Enumerable 模块。</p><h2 id="Each"><a href="#Each" class="headerlink" title="Each"></a>Each</h2><p>任何枚举类型都包含一个each方法，其作用是将其中的元素逐个地作为参数传递给代码块。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里的每个方法都是基于each构建</span></span><br><span class="line">p Enumerable.instance_methods(<span class="literal">false</span>).sort</span><br><span class="line"><span class="comment">=begin</span></span><br><span class="line"><span class="comment">[:all?, :any?, :chain, :chunk, :chunk_while, :collect, :collect_concat, :count, :cycle, :detect, :drop, :drop_while, :each_cons, :each_entry, :each_slice, :each_with_index, :each_with_object, :entries, :filter, :find, :find_all, :find_index, :first, :flat_map, :grep, :grep_v, :group_by, :include?, :inject, :lazy, :map, :max, :max_by, :member?, :min, :min_by, :minmax, :minmax_by, :none?, :one?, :partition, :reduce, :reject, :reverse_each, :select, :slice_after, :slice_before, :slice_when, :sort, :sort_by, :sum, :take, :take_while, :to_a, :to_h, :uniq, :zip]</span></span><br><span class="line"><span class="comment">=end</span></span><br></pre></td></tr></table></figure><p><strong>Rainbow 混合了Enumerable模块，则自动赋予了整套基于 each 方法构建的方法。</strong><br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rainbow</span></span></span><br><span class="line">    <span class="keyword">include</span> Enumerable</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">each</span></span></span><br><span class="line">        <span class="keyword">yield</span> <span class="string">"Red"</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="string">"Orange"</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="string">"Green"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">a = Rainbow.new</span><br><span class="line">p a.map(&amp;<span class="symbol">:upcase</span>)</span><br><span class="line"><span class="comment"># ["RED", "ORANGE", "GREEN"]</span></span><br></pre></td></tr></table></figure></p><h2 id="符号参数"><a href="#符号参数" class="headerlink" title="符号参数"></a>符号参数</h2><p>可以在方法参数的位置使用如<strong>:upcase</strong>这样的符号并在前面加上&amp;，它的效果与在代码块中调用每个元素同符号名称相等的方法的作用相同。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p [<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>].map(&amp;<span class="symbol">:downcase</span>)</span><br></pre></td></tr></table></figure></p><h2 id="Enumerator-枚举器"><a href="#Enumerator-枚举器" class="headerlink" title="Enumerator(枚举器)"></a>Enumerator(枚举器)</h2><ol><li>迭代器本质上是一个方法，它将一个或多个元素传递到代码块中。</li><li>枚举器本质上一枚举器是一个简单的可枚举对象。它有 each 方法，并使用Enumerable模块定义其所有常用的方法。</li><li>枚举器只需要有一个“迭代每一个”的逻辑，它已经知道后面的事情可以一一展开。<ul><li>Enumerator.new 伴随一个包含稍后会用到的 each 逻辑的代码块</li><li>创建一个基于可存在枚举对象的枚举器，这样枚举器的 each 方法就会从那个枚举对象的特定方法中抽取它的元素用于迭代</li></ul></li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">e = Enumerator.new <span class="keyword">do</span> <span class="params">|y|</span></span><br><span class="line">    y &lt;&lt; <span class="number">1</span></span><br><span class="line">    y &lt;&lt; <span class="number">2</span></span><br><span class="line">    y &lt;&lt; <span class="number">3</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p e.to_a</span><br><span class="line">p e.map &#123;<span class="params">|x|</span> x * <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Some important concepts in Ruby
    
    </summary>
    
    
      <category term="Programming Language" scheme="https://zhangruochi.com/categories/Programming-Language/"/>
    
    
  </entry>
  
  <entry>
    <title>Topological Sorting</title>
    <link href="https://zhangruochi.com/Topological-Sorting/2019/11/20/"/>
    <id>https://zhangruochi.com/Topological-Sorting/2019/11/20/</id>
    <published>2019-11-20T13:54:11.000Z</published>
    <updated>2019-11-20T14:25:40.986Z</updated>
    
    <content type="html"><![CDATA[<p>在图论中，拓扑排序（Topological Sorting）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。且该序列必须满足下面两个条件：</p><ol><li>每个顶点出现且只出现一次。</li><li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。</li></ol><p>有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。例如，下面这个图：</p><p><img src="1.png" alt></p><p>它是一个 DAG 图，那么如何写出它的拓扑排序呢？这里说一种比较常用的方法：</p><ol><li>从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出。</li><li>从图中删除该顶点和所有以它为起点的有向边。</li><li>重复 1 和 2 直到当前的 DAG 图为空。</li><li><strong>当前图中不存在无前驱的顶点说明有向图中必然存在环</strong></li></ol><p><img src="2.png" alt></p><p>于是，得到拓扑排序后的结果是[1, 2, 4, 3, 5]。 通常，一个有向无环图可以有一个或多个拓扑排序序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topoSort</span><span class="params">(G)</span>:</span></span><br><span class="line">    in_degree = &#123;node:<span class="number">0</span> <span class="keyword">for</span> node <span class="keyword">in</span> G&#125;</span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> G:</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> G[u]:</span><br><span class="line">            in_degree[v] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    queue = [u <span class="keyword">for</span> u <span class="keyword">in</span> in_degree <span class="keyword">if</span> in_degree[u] == <span class="number">0</span>]</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        s = queue.pop()</span><br><span class="line">        res.append(s)</span><br><span class="line">        <span class="keyword">for</span> u <span class="keyword">in</span> G[s]:</span><br><span class="line">            in_degree[u] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> in_degree[u] == <span class="number">0</span>:</span><br><span class="line">                queue.append(u)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">G=&#123;</span><br><span class="line">    <span class="number">1</span>: [<span class="number">2</span>,<span class="number">4</span>],</span><br><span class="line">    <span class="number">2</span>: [<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">    <span class="number">3</span>: [<span class="number">5</span>],</span><br><span class="line">    <span class="number">4</span>: [<span class="number">3</span>,<span class="number">5</span>],</span><br><span class="line">    <span class="number">5</span>: [],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res=topoSort(G)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><h2 id="Leetcode-207-Course-Schedule"><a href="#Leetcode-207-Course-Schedule" class="headerlink" title="Leetcode 207 Course Schedule"></a>Leetcode 207 <a href="https://leetcode.com/problems/course-schedule/" target="_blank" rel="noopener">Course Schedule</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">There are a total of n courses you have to take, labeled from 0 to n-1.</span><br><span class="line"></span><br><span class="line">Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</span><br><span class="line"></span><br><span class="line">Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 2, [[1,0]] </span><br><span class="line">Output: true</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">             To take course 1 you should have finished course 0. So it is possible.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 2, [[1,0],[0,1]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">             To take course 1 you should have finished course 0, and to take course 0 you should</span><br><span class="line">             also have finished course 1. So it is impossible.</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.</span><br><span class="line">You may assume that there are no duplicate edges in the input prerequisites.</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span><span class="params">(self, numCourses: int, prerequisites: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        G = &#123;node:[] <span class="keyword">for</span> node <span class="keyword">in</span> range(numCourses)&#125;</span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> prerequisites:</span><br><span class="line">            G[edge[<span class="number">1</span>]].append(edge[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">top_sort</span><span class="params">(G)</span>:</span></span><br><span class="line">            in_degree = &#123;node: <span class="number">0</span> <span class="keyword">for</span> node <span class="keyword">in</span> G&#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> u <span class="keyword">in</span> G:</span><br><span class="line">                <span class="keyword">for</span> v <span class="keyword">in</span> G[u]:</span><br><span class="line">                    in_degree[v] += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            queue = [node <span class="keyword">for</span> node <span class="keyword">in</span> in_degree <span class="keyword">if</span> in_degree[node] == <span class="number">0</span>]</span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                cur_node = queue.pop()</span><br><span class="line">                res.append(cur_node)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> v <span class="keyword">in</span> G[cur_node]:</span><br><span class="line">                    in_degree[v] -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> in_degree[v] == <span class="number">0</span>:</span><br><span class="line">                        queue.append(v)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> len(res) == len(G) <span class="keyword">else</span> <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> top_sort(G)</span><br></pre></td></tr></table></figure><blockquote><p>reference <a href="https://blog.csdn.net/lisonglisonglisong/article/details/45543451" target="_blank" rel="noopener">https://blog.csdn.net/lisonglisonglisong/article/details/45543451</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在图论中，拓扑排序（Topological Sorting）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。且该序列必须满足下面两个条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个顶点出现且只出现一次。&lt;/li&gt;
&lt;li&gt;若存在一条从顶
      
    
    </summary>
    
    
      <category term="Data Structure and Algorithm" scheme="https://zhangruochi.com/categories/Data-Structure-and-Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>Union Find</title>
    <link href="https://zhangruochi.com/Union-Find/2019/11/19/"/>
    <id>https://zhangruochi.com/Union-Find/2019/11/19/</id>
    <published>2019-11-19T15:06:45.000Z</published>
    <updated>2019-11-19T15:18:12.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题。常常在使用中以森林来表示。并查集有三种基本操作，获得根节点，判断两节点是否连通，以及将两不连通的节点相连（相当于将两节点各自的集合合并）。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>用UnionFind类来表示一个并查集，在构造函数中，初始化一个数组parent，parent[i]表示的含义为，索引为i的节点，它的直接父节点为parent[i]。初始化时各个节点都不相连，因此初始化parent[i]=i，让自己成为自己的父节点，从而实现各节点不互连。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">    self.parent = list(range(n))</span><br></pre></td></tr></table></figure><p>由于parent[i]仅表示自己的直接父节点，查询两个节点是否相交需要比较它们的根节点是否相同。因此要封装一个查询自己根节点的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_root</span><span class="params">(self, i)</span>:</span></span><br><span class="line">   <span class="keyword">while</span> i != self.parent[i]:</span><br><span class="line">       i = self.parent[i]</span><br><span class="line">   <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><p>接下来可以通过来比较根节点是否相同来判断两节点是否连通。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_connected</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.get_root(i) == self.get_root(j)</span><br></pre></td></tr></table></figure><p>当要连通两个节点时，我们要将其中一个节点的根节点的parent，设置为另一个节点的根节点。注意，连通两个节点并非仅仅让两节点自身相连，实际上是让它们所属的集合实现合并。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">    i_root = self.get_root(i)</span><br><span class="line">    j_root = self.get_root(j)</span><br><span class="line">    self.parent[i_root] = j_root</span><br></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>由于调用get_root时需要通过不断找自己的直接父节点，来寻找根节点，如果这棵树的层级过深，会导致性能受到严重影响。因此我们需要在union时，尽可能的减小合并后的树的高度。在构造函数中新建一个数组rank，rank[i]表示节点i所在的集合的树的高度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">    self.parent = list(range(n))</span><br><span class="line">    self.rank = [<span class="number">0</span>] * len(self.parent)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">    i_root = self.get_root(i)</span><br><span class="line">    j_root = self.get_root(j)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.rank[i_root] == self.rank[j_root]:</span><br><span class="line">        self.parent[i_root] = j_root</span><br><span class="line">        self.rank[j_root] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> self.rank[i_root] &gt; self.rank[j_root]:</span><br><span class="line">        self.parent[j_root] = i_root</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.parent[i_root] = j_root</span><br></pre></td></tr></table></figure><p>通过对union操作的改良可以防止树的高度过高。我们还可以对get_root操作本身进行优化。<br>当前每次执行get_root时，需要一层一层的找到自己的父节点，很费时。由于根节点没有父节点，并且文章开始处提到过如果一个节点没有父节点，那么它的父节点就是自己，因此可以说只有根节点的父节点是自己本身。现在我们加上一个判断，判断当前节点的父节点是否为根节点，如果不为根节点，就递归地将自己的父节点设置为根节点，最后返回自己的父节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_root</span><span class="params">(self, i)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.parent[i] != self.parent[self.parent[i]]:</span><br><span class="line">        self.parent[i] = self.get_root(self.parent[i])</span><br><span class="line">    <span class="keyword">return</span> self.parent[i]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题。常常在使用中以森林来表示。并查集有三种基本操作，获得根节点，判断两节点是
      
    
    </summary>
    
    
      <category term="Data Structure and Algorithm" scheme="https://zhangruochi.com/categories/Data-Structure-and-Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>Greedy Algorithm</title>
    <link href="https://zhangruochi.com/Greedy-Algorithm/2019/11/19/"/>
    <id>https://zhangruochi.com/Greedy-Algorithm/2019/11/19/</id>
    <published>2019-11-19T14:17:16.000Z</published>
    <updated>2019-11-19T16:37:31.017Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>贪心算法</strong>，是指在对问题求解时，总是做出再当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是某种意义上的局部最优解。贪心算法没有固定算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。</p><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><ol><li>建立数学模型来描述问题</li><li>把求解的问题分成若干个子问题</li><li>对每一子问题求解，得到子问题的局部最优解</li><li>把子问题的解局部最优解合成原来解问题的一个解</li></ol><h2 id="适用的问题"><a href="#适用的问题" class="headerlink" title="适用的问题"></a>适用的问题</h2><p><strong>局部最优策略能导致产生全局最优解</strong></p><h2 id="最小生成树问题"><a href="#最小生成树问题" class="headerlink" title="最小生成树问题"></a>最小生成树问题</h2><p>给定一个无向联通带权图G(V,E). G中的每一条边$E_i$权值为$w_i$。如果G的子图G’是一个包含G中所有顶点的子图，那么G’称为G的最小生成树，如果G’的边的权值最小.</p><p><img src="1.png" alt></p><h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><p>Kruskal算法是基于贪心的思想得到的。首先我们把所有的边按照权值先从小到大排列，接着按照顺序选取每条边，如果这条边的两个端点不属于同一集合，那么就将它们合并，直到所有的点都属于同一个集合为止。至于怎么合并到一个集合，那么这里我们就可以用到一个工具——-并查集。换而言之，Kruskal算法就是基于并查集的贪心算法。</p><ol><li>将图G看做一个森林，每个顶点为一棵独立的树</li><li>将所有的边加入集合S，即一开始S = E</li><li>从S中拿出一条最短的边(u,v)，如果(u,v)不在同一棵树内，则连接u,v合并这两棵树，同时将(u,v)加入生成树的边集E’</li><li>重复(3)直到所有点属于同一棵树，边集E’就是一棵最小生成树</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,items)</span>:</span></span><br><span class="line">        self.parent = &#123;item:item <span class="keyword">for</span> item <span class="keyword">in</span> items&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_root</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> i != self.parent[i]:</span><br><span class="line">            i = self.parent[i]</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_connected</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.get_root(i) == self.get_root(j)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        i_root = self.get_root(i)</span><br><span class="line">        j_root = self.get_root(j)</span><br><span class="line">        self.parent[i_root] = j_root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kruskal</span><span class="params">(G)</span>:</span></span><br><span class="line">    nodes = list(G.keys())</span><br><span class="line">    uf = UnionFind(nodes)</span><br><span class="line"></span><br><span class="line">    res_deges = set()</span><br><span class="line">    res_weight = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    edges = set()</span><br><span class="line">    <span class="keyword">for</span> node_1 <span class="keyword">in</span> G:</span><br><span class="line">        <span class="keyword">for</span> node_2 <span class="keyword">in</span> G[node_1]:</span><br><span class="line">            <span class="keyword">if</span> node_1 &lt; node_2:</span><br><span class="line">                edges.add((node_1,node_2, G[node_1][node_2]))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                edges.add((node_2,node_1, G[node_1][node_2]))</span><br><span class="line">    edges = list(edges)</span><br><span class="line">    edges.sort(key = <span class="keyword">lambda</span> edge: edge[<span class="number">-1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">        node_1,node_2,weight = edge</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> uf.is_connected(node_1,node_2):</span><br><span class="line">            uf.union(node_1,node_2)</span><br><span class="line">            res_deges.add(edge)</span><br><span class="line">            res_weight += weight</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res_deges,res_weight</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    graph = &#123;<span class="string">'A'</span>:&#123;<span class="string">'B'</span>:<span class="number">7</span>,<span class="string">'D'</span>:<span class="number">5</span>&#125;,</span><br><span class="line">             <span class="string">'B'</span>:&#123;<span class="string">'A'</span>:<span class="number">7</span>,<span class="string">'C'</span>:<span class="number">8</span>,<span class="string">'D'</span>:<span class="number">9</span>,<span class="string">'E'</span>:<span class="number">7</span>&#125;,</span><br><span class="line">             <span class="string">'C'</span>:&#123;<span class="string">'B'</span>:<span class="number">8</span>,<span class="string">'E'</span>:<span class="number">5</span>&#125;,</span><br><span class="line">             <span class="string">'D'</span>:&#123;<span class="string">'A'</span>:<span class="number">5</span>,<span class="string">'B'</span>:<span class="number">9</span>,<span class="string">'E'</span>:<span class="number">15</span>,<span class="string">'F'</span>:<span class="number">6</span>&#125;,</span><br><span class="line">             <span class="string">'E'</span>:&#123;<span class="string">'B'</span>:<span class="number">7</span>,<span class="string">'C'</span>:<span class="number">5</span>,<span class="string">'D'</span>:<span class="number">15</span>,<span class="string">'F'</span>:<span class="number">8</span>,<span class="string">'G'</span>:<span class="number">9</span>&#125;,</span><br><span class="line">             <span class="string">'F'</span>:&#123;<span class="string">'D'</span>:<span class="number">6</span>,<span class="string">'E'</span>:<span class="number">8</span>,<span class="string">'G'</span>:<span class="number">11</span>&#125;,</span><br><span class="line">             <span class="string">'G'</span>:&#123;<span class="string">'E'</span>:<span class="number">9</span>,<span class="string">'F'</span>:<span class="number">11</span>&#125;</span><br><span class="line">             &#125;</span><br><span class="line">    edges, weight = kruskal(graph)</span><br><span class="line">    print(edges)</span><br><span class="line">    print(weight)</span><br></pre></td></tr></table></figure><h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><ol><li>以某一个点开始，寻找当前该点可以访问的所有的边；</li><li>在已经寻找的边中发现最小边，这个边必须有一个点还没有访问过，将还没有访问的点加入我们的集合，记录添加的边；</li><li>寻找当前集合可以访问的所有边，重复2的过程，直到没有新的点可以加入；</li><li>此时由所有边构成的树即为最小生成树。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prim</span><span class="params">(graph, root)</span>:</span></span><br><span class="line">    </span><br><span class="line">    nodes = list(graph)</span><br><span class="line">    nodes.remove(root)</span><br><span class="line">    visited = [root]</span><br><span class="line">    edges = set()</span><br><span class="line">    weight = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> nodes:</span><br><span class="line">        distance = float(<span class="string">'inf'</span>) </span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> visited:</span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> graph[s]:</span><br><span class="line">                <span class="keyword">if</span> d <span class="keyword">in</span> visited <span class="keyword">or</span> s == d:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> graph[s][d] &lt; distance:</span><br><span class="line">                    distance = graph[s][d]</span><br><span class="line">                    node_1 = s</span><br><span class="line">                    node_2 = d</span><br><span class="line">        edges.add((node_1,node_2,graph[node_1][node_2]))</span><br><span class="line">        weight += graph[node_1][node_2]</span><br><span class="line">        visited.append(node_2)</span><br><span class="line">        nodes.remove(node_2)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> edges,weight</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    graph = &#123;<span class="string">'A'</span>:&#123;<span class="string">'B'</span>:<span class="number">7</span>,<span class="string">'D'</span>:<span class="number">5</span>&#125;,</span><br><span class="line">             <span class="string">'B'</span>:&#123;<span class="string">'A'</span>:<span class="number">7</span>,<span class="string">'C'</span>:<span class="number">8</span>,<span class="string">'D'</span>:<span class="number">9</span>,<span class="string">'E'</span>:<span class="number">7</span>&#125;,</span><br><span class="line">             <span class="string">'C'</span>:&#123;<span class="string">'B'</span>:<span class="number">8</span>,<span class="string">'E'</span>:<span class="number">5</span>&#125;,</span><br><span class="line">             <span class="string">'D'</span>:&#123;<span class="string">'A'</span>:<span class="number">5</span>,<span class="string">'B'</span>:<span class="number">9</span>,<span class="string">'E'</span>:<span class="number">15</span>,<span class="string">'F'</span>:<span class="number">6</span>&#125;,</span><br><span class="line">             <span class="string">'E'</span>:&#123;<span class="string">'B'</span>:<span class="number">7</span>,<span class="string">'C'</span>:<span class="number">5</span>,<span class="string">'D'</span>:<span class="number">15</span>,<span class="string">'F'</span>:<span class="number">8</span>,<span class="string">'G'</span>:<span class="number">9</span>&#125;,</span><br><span class="line">             <span class="string">'F'</span>:&#123;<span class="string">'D'</span>:<span class="number">6</span>,<span class="string">'E'</span>:<span class="number">8</span>,<span class="string">'G'</span>:<span class="number">11</span>&#125;,</span><br><span class="line">             <span class="string">'G'</span>:&#123;<span class="string">'E'</span>:<span class="number">9</span>,<span class="string">'F'</span>:<span class="number">11</span>&#125;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">    edges, weight = prim(graph,<span class="string">'A'</span>)</span><br><span class="line">    print(edges)</span><br><span class="line">    print(weight)</span><br></pre></td></tr></table></figure><h2 id="leetcode-455-Assign-Cookies"><a href="#leetcode-455-Assign-Cookies" class="headerlink" title="leetcode 455 Assign Cookies"></a>leetcode 455 <a href="https://leetcode.com/problems/assign-cookies/" target="_blank" rel="noopener">Assign Cookies</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj &gt;= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line">You may assume the greed factor is always positive. </span><br><span class="line">You cannot assign more than one cookie to one child.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [1,2,3], [1,1]</span><br><span class="line"></span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. </span><br><span class="line">And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.</span><br><span class="line">You need to output 1.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [1,2], [1,2,3]</span><br><span class="line"></span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. </span><br><span class="line">You have 3 cookies and their sizes are big enough to gratify all of the children, </span><br><span class="line">You need to output 2.</span><br></pre></td></tr></table></figure><blockquote><p>因为最小的孩子最容易得到满足，因此先满足最小孩子。给一个孩子的饼干应当尽量小又能满足该孩子，这样大饼干就能拿来给满足度比较大的孩子。<br>假设在某次选择中，贪心策略选择给第 i 个孩子分配第 m 个饼干，并且第 i 个孩子满足度最小，第 m 个饼干为可以满足第 i 个孩子的最小饼干，利用贪心策略最终可以满足 k 个孩子。假设最优策略在这次选择中给 i 个孩子分配第 n 个饼干，并且这个饼干大于第 m 个饼干。我们发现使用第 m 个饼干去替代第 n 个饼干完全不影响后续的结果，因此不存在比贪心策略更优的策略，即贪心策略就是最优策略。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContentChildren</span><span class="params">(self, g: List[int], s: List[int])</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span>; i = <span class="number">0</span>; j = <span class="number">0</span></span><br><span class="line">        g.sort()</span><br><span class="line">        s.sort()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> i &lt; len(g) <span class="keyword">and</span> j &lt; len(s):</span><br><span class="line">            <span class="keyword">if</span> g[i] &lt;= s[j]:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;贪心算法&lt;/strong&gt;，是指在对问题求解时，总是做出再当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的
      
    
    </summary>
    
    
      <category term="Data Structure and Algorithm" scheme="https://zhangruochi.com/categories/Data-Structure-and-Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>Flee from famine</title>
    <link href="https://zhangruochi.com/Flee-from-famine/2019/11/19/"/>
    <id>https://zhangruochi.com/Flee-from-famine/2019/11/19/</id>
    <published>2019-11-19T05:11:40.000Z</published>
    <updated>2019-11-19T05:16:51.395Z</updated>
    
    <content type="html"><![CDATA[<p>我妈打电话给我说，觉得难受，感觉像在“逃荒”一样。<br>我会让一切都变好的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我妈打电话给我说，觉得难受，感觉像在“逃荒”一样。&lt;br&gt;我会让一切都变好的。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Private" scheme="https://zhangruochi.com/categories/Private/"/>
    
    
  </entry>
  
  <entry>
    <title>Knapsack problem</title>
    <link href="https://zhangruochi.com/Knapsack-problem/2019/11/16/"/>
    <id>https://zhangruochi.com/Knapsack-problem/2019/11/16/</id>
    <published>2019-11-16T22:38:52.000Z</published>
    <updated>2019-11-16T22:43:15.540Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Backtracking"><a href="#Backtracking" class="headerlink" title="Backtracking"></a>Backtracking</h2><p>我们把物体依次排列，整个问题就分为n个阶段，每个阶段对应一个物品 i 怎样选择。</p><p><img src="bag.jpg" alt="bag.jpg"><br>观察解空间树，每个结点我们用(i,cw)来表示。i表示将要觉得i个物品是否装入背包，只有装和不装两种情况。cw 表示当前背包中的重量。比如(2,2)表示我们将要觉得第2个物品是否装入背包，在决策前，背包中物品的总重量是2。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">weights = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">3</span>]</span><br><span class="line">W = <span class="number">9</span></span><br><span class="line">n = <span class="number">5</span> </span><br><span class="line"></span><br><span class="line">max_weight = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking_bag</span><span class="params">(i, cw, items)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> max_weight,methods</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    i: test the item i</span></span><br><span class="line"><span class="string">    cw: current total weight</span></span><br><span class="line"><span class="string">    weights: the weight of items</span></span><br><span class="line"><span class="string">    W: total weight the bag can load</span></span><br><span class="line"><span class="string">    n: the number of items</span></span><br><span class="line"><span class="string">    max_weight: the max weight the bag can load</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> i == n:</span><br><span class="line">        <span class="keyword">if</span> cw &lt;= W <span class="keyword">and</span> cw &gt;= max_weight:</span><br><span class="line">            <span class="keyword">if</span> cw &gt; max_weight:</span><br><span class="line">                max_weight = cw</span><br><span class="line">                methods = []</span><br><span class="line">                methods.append(items[:])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                methods.append(items[:])</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">    backtracking_bag(i+<span class="number">1</span>,cw,items)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cw + weights[i] &lt;= W:</span><br><span class="line">        items[i] = <span class="number">1</span></span><br><span class="line">        backtracking_bag(i+<span class="number">1</span>,cw+weights[i],items)</span><br><span class="line">        items[i] = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    items = [<span class="number">0</span>] * n</span><br><span class="line">    methods = []</span><br><span class="line">    backtracking_bag(<span class="number">0</span>,<span class="number">0</span>,items)</span><br><span class="line">    print(max_weight)</span><br><span class="line">    print(methods)</span><br></pre></td></tr></table></figure><h2 id="Backtracking-with-memory"><a href="#Backtracking-with-memory" class="headerlink" title="Backtracking with memory"></a>Backtracking with memory</h2><p>我们发现，很多子问题是重复的。比如f(2,2) 和 f(3,6)都被重复计算很多次。因此，我们可以用<strong>备忘录</strong>的方法来解决重复计算的问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">weights = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">3</span>]</span><br><span class="line">W = <span class="number">9</span></span><br><span class="line">n = <span class="number">5</span> </span><br><span class="line"></span><br><span class="line">max_weight = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking_memory_bag</span><span class="params">(i, cw, items)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> max_weight,methods,memory</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    i: test the item i</span></span><br><span class="line"><span class="string">    cw: current total weight</span></span><br><span class="line"><span class="string">    weights: the weight of items</span></span><br><span class="line"><span class="string">    W: total weight the bag can load</span></span><br><span class="line"><span class="string">    n: the number of items</span></span><br><span class="line"><span class="string">    max_weight: the max weight the bag can load</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> i == n:</span><br><span class="line">        <span class="keyword">if</span> cw &lt;= W <span class="keyword">and</span> cw &gt;= max_weight:</span><br><span class="line">            <span class="keyword">if</span> cw &gt; max_weight:</span><br><span class="line">                max_weight = cw</span><br><span class="line">                methods = []</span><br><span class="line">                methods.append(items[:])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                methods.append(items[:])</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> memory[i][cw]:</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    memory[i][cw] = <span class="keyword">True</span>  <span class="comment"># remember the state of i </span></span><br><span class="line"></span><br><span class="line">    backtracking_bag(i+<span class="number">1</span>,cw,items)</span><br><span class="line">    <span class="keyword">if</span> cw + weights[i] &lt;= W:</span><br><span class="line">        items[i] = <span class="number">1</span></span><br><span class="line">        backtracking_bag(i+<span class="number">1</span>,cw+weights[i],items)</span><br><span class="line">        items[i] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    items = [<span class="number">0</span>] * n</span><br><span class="line">    methods = []</span><br><span class="line">    memory = [[<span class="keyword">False</span>]*W <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    backtracking_bag(<span class="number">0</span>,<span class="number">0</span>,items)</span><br><span class="line">    print(max_weight)</span><br><span class="line">    print(methods)</span><br></pre></td></tr></table></figure><h2 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h2><p>我们把整个求解的过程分为n个阶段，每个阶段会决策一个物品是否放入背包中。每个物品决策完成后，背包中的重量会有多种情况。<br>动态规划问题的解决步骤一般可以总结为 3 步：</p><ol><li>定义数组元素的含义<br>我们用 dp[n][cw] 来表示在第n个阶段重量为cw的状态。</li><li>找出状态转移方程。<ul><li>把第 i 个物品装入背包中<script type="math/tex; mode=display">dp[i][cw + weights[i]] = true</script></li><li>不把第 i 个物品装入背包中<script type="math/tex; mode=display">dp[i][cw] = true</script>比如第 0 个物品的重量是2，要么装入背包，要么不装入背包。决策完之后会对应背包的两种状态，背包中物品的总重量为 0 或者 2。<br>我们用dp[0][0] = true 和 dp[0][2] = true表示。<br><img src="dp.jpg" alt><br><img src="dp2.jpg" alt></li></ul></li><li>初始值。</li></ol><ul><li>第 0 个物品不装: dp[0][0] = true</li><li>第 0 个物品装: dp[0][weights[i]] = true</li></ul><pre><code class="lang-python">import pprintweights = [2,2,4,6,3]W = 9n = 5 def dp_bag(weights,W,n):    dp = [[0] * (W+1) for i in range(n)]     ## 第 0 个物品不装    dp[0][0] = 1    ##  第 0 个物品装    if weights[0] &lt; W:        dp[0][weights[0]] = 1    for i in range(1,n):        for j in range(W):            ## 不把 i 放入背包中，当前背包重量不变            if dp[i-1][j]:                dp[i][j] = 1        for j in range(W):            ## 把 i 放入背包中            if j + weights[i] &lt;= W and dp[i-1][j]:                dp[i][j+weights[i]] = 1    pprint.pprint(dp)    for i in range(W,-1,-1):        if dp[-1][i]:            return iif __name__ == &#39;__main__&#39;:    max_weight = dp_bag(weights,W,n)    print(max_weight)</code></pre><blockquote><p>reference from 数据结构与算法之美 王争</p></blockquote>]]></content>
    
    <summary type="html">
    
      Different methods to solve Knapsack problem
    
    </summary>
    
    
      <category term="Data Structure and Algorithm" scheme="https://zhangruochi.com/categories/Data-Structure-and-Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>Dynamic Programming</title>
    <link href="https://zhangruochi.com/Dynamic-Programming/2019/11/16/"/>
    <id>https://zhangruochi.com/Dynamic-Programming/2019/11/16/</id>
    <published>2019-11-16T17:59:59.000Z</published>
    <updated>2019-11-17T14:46:47.990Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>动态规划，无非就是利用历史记录，来避免我们的重复计算。</p></blockquote><ol><li><strong>最优子结构</strong>。最优子结构指的是问题的最优解包含子问题的最优解。反过来说，我们可以通过子问题的最优解来推导出问题的最优解。或者理解为后面阶段的状态可以由前面阶段的状态推导出来。</li><li><strong>无后效性</strong>。在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步步推导出来的。同时，某阶段的状态值一旦确定，就不受之后阶段的决策影响。</li><li><strong>重复子问题</strong>。不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。</li></ol><h2 id="动态规划三大步骤"><a href="#动态规划三大步骤" class="headerlink" title="动态规划三大步骤"></a>动态规划三大步骤</h2><ol><li>第一步骤：定义数组元素的含义，上面说了，我们会用一个数组，来保存历史数组，假设用一维数组 dp[] 吧。这个时候有一个非常非常重要的点，就是规定这个数组元素的含义，例如 dp[i] 是代表什么意思？</li><li>第二步骤：找出状态转移方程。当我们要计算 dp[n] 时，是可以利用 dp[n-1]，dp[n-2]…..dp[1]，来推出 dp[n] 的，也就是可以利用历史数据来推出新的元素值，所以我们要找出数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，这个就是他们的关系式了。</li><li>第三步骤：找出初始值。学过数学归纳法的都知道，虽然我们知道了数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，我们可以通过 dp[n-1] 和 dp[n-2] 来计算 dp[n]，但是，我们得知道初始值啊，例如一直推下去的话，会由 dp[3] = dp[2] + dp[1]。而 dp[2] 和 dp[1] 是不能再分解的了，所以我们必须要能够直接获得 dp[2] 和 dp[1] 的值，而这，就是所谓的初始值。</li></ol><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="leetcode-70-Climbing-Stairs"><a href="#leetcode-70-Climbing-Stairs" class="headerlink" title="leetcode 70 Climbing Stairs"></a>leetcode 70 <a href="https://leetcode.com/problems/climbing-stairs/" target="_blank" rel="noopener">Climbing Stairs</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">You are climbing a stair case. It takes n steps to reach to the top.</span><br><span class="line"></span><br><span class="line">Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</span><br><span class="line"></span><br><span class="line">Note: Given n will be a positive integer.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step</span><br><span class="line">2. 2 steps</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: There are three ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step + 1 step</span><br><span class="line">2. 1 step + 2 steps</span><br><span class="line">3. 2 steps + 1 step</span><br></pre></td></tr></table></figure><ol><li>定义数组元素的含义<br>我们就定义 dp[i] 的含义为：跳上一个 i 级的台阶总共有 dp[i] 种跳法。</li><li>找出数组元素间的关系式<br>青蛙到达第 n 级的台阶有两种方式: 从第 n-1 级跳上来 和 从第 n-2 级跳上来。因此关系式为： <script type="math/tex; mode=display">dp[n] = dp[n-1] + dp[n-2]</script></li><li>找出初始条件<br>dp[0] = 0. dp[1] = 1. 即 n &lt;= 1 时，dp[n] = n.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        dp = [<span class="number">-1</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="leetcode-62-Unique-Paths"><a href="#leetcode-62-Unique-Paths" class="headerlink" title="leetcode 62   Unique Paths"></a>leetcode 62   <a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">Unique Paths</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">问题描述：</span><br><span class="line"></span><br><span class="line">A robot is located at the top-left corner of a m x n grid (marked &apos;Start&apos; in the diagram below).</span><br><span class="line"></span><br><span class="line">The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &apos;Finish&apos; in the diagram below).</span><br><span class="line"></span><br><span class="line">How many possible unique paths are there?</span><br><span class="line">Note: m and n will be at most 100.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: m = 3, n = 2</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:</span><br><span class="line">1. Right -&gt; Right -&gt; Down</span><br><span class="line">2. Right -&gt; Down -&gt; Right</span><br><span class="line">3. Down -&gt; Right -&gt; Right</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: m = 7, n = 3</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure><ol><li>定义数组元素的含义<br>当机器人从左上角走到(i, j) 这个位置时，一共有 dp[i][j] 种路径</li><li>找出关系数组元素间的关系式<script type="math/tex; mode=display">dp[i][j] = dp[i-1][j] + dp[i][j-1]</script></li><li>找出初始值</li></ol><ul><li>dp[0][0…n-1] = 1; // 相当于最上面一行，机器人只能一直往左走</li><li>dp[0…m-1][0] = 1; // 相当于最左面一列，机器人只能一直往下走</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> m <span class="keyword">or</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="number">1</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> range(m)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="leetcode-64-Minimum-Path-Sum"><a href="#leetcode-64-Minimum-Path-Sum" class="headerlink" title="leetcode 64  Minimum Path Sum"></a>leetcode 64  <a href="https://leetcode.com/problems/minimum-path-sum/" target="_blank" rel="noopener">Minimum Path Sum</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">问题描述：</span><br><span class="line"></span><br><span class="line">Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.</span><br><span class="line"></span><br><span class="line">Note: You can only move either down or right at any point in time.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Because the path 1→3→1→1→1 minimizes the sum.</span><br></pre></td></tr></table></figure><ol><li>定义数组元素的含义<br>当机器人从左上角走到(i, j) 这个位置时，最小的路径和是 dp[i][j]</li><li>找出关系数组元素间的关系式<br>由于机器人可以向下走或者向右走，所以有两种方式到达:</li></ol><ul><li>一种是从 (i-1, j) 这个位置走一步到达</li><li>一种是从(i, j - 1) 这个位置走一步到达<br>不过这次不是计算所有可能路径，而是<strong>计算哪一个路径和是最小的</strong>，那么我们要从这两种方式中，选择一种，使得dp[i][j] 的值是最小的，显然有:<script type="math/tex; mode=display">dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + arr[i][j]</script></li></ul><ol><li>找出初始值</li></ol><ul><li>dp[0][j] = arr[0][j] + dp[0][j-1]; // 相当于最上面一行，机器人只能一直往左走</li><li>dp[i][0] = arr[i][0] + dp[i][0]; // 相当于最左面一列，机器人只能一直往下走</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        m,n = len(grid),len(grid[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> range(m)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">## initialize </span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            dp[<span class="number">0</span>][i] = grid[<span class="number">0</span>][i] + dp[<span class="number">0</span>][i<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            dp[j][<span class="number">0</span>] = grid[j][<span class="number">0</span>] + dp[j<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                dp[i][j] = min(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]) + grid[i][j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="leetcode-72-Edit-Distance"><a href="#leetcode-72-Edit-Distance" class="headerlink" title="leetcode 72   Edit Distance"></a>leetcode 72   <a href="https://leetcode.com/problems/edit-distance/" target="_blank" rel="noopener">Edit Distance</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.</span><br><span class="line"></span><br><span class="line">You have the following 3 operations permitted on a word:</span><br><span class="line"></span><br><span class="line">Insert a character</span><br><span class="line">Delete a character</span><br><span class="line">Replace a character</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">horse -&gt; rorse (replace &apos;h&apos; with &apos;r&apos;)</span><br><span class="line">rorse -&gt; rose (remove &apos;r&apos;)</span><br><span class="line">rose -&gt; ros (remove &apos;e&apos;)</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: </span><br><span class="line">intention -&gt; inention (remove &apos;t&apos;)</span><br><span class="line">inention -&gt; enention (replace &apos;i&apos; with &apos;e&apos;)</span><br><span class="line">enention -&gt; exention (replace &apos;n&apos; with &apos;x&apos;)</span><br><span class="line">exention -&gt; exection (replace &apos;n&apos; with &apos;c&apos;)</span><br><span class="line">exection -&gt; execution (insert &apos;u&apos;)</span><br></pre></td></tr></table></figure><ol><li>定义数组元素的含义<br>当字符串 word1 的长度为 i，字符串 word2 的长度为 j 时，将 word1 转化为 word2 所使用的最少操作次数为 dp[i][j]</li><li>找出关系数组元素间的关系式<br>比起其他题，这道题相对比较难找一点，但是，不管多难找，大部分情况下，dp[i][j] 和 dp[i-1] [j]、dp[i] [j-1]、dp[i-1] [j-1] 肯定存在某种关系。因为我们的目标就是，<strong>从规模小的，通过一些操作，推导出规模大的</strong>。对于这道题，我们可以对 word1 进行三种操作:<ul><li>插入一个字符 </li><li>删除一个字符 </li><li>替换一个字符</li></ul><ol><li>如果我们 word1[i] 与 word2 [j] 相等，这个时候不需要进行任何操作。<script type="math/tex; mode=display">dp[i][j] = dp[i-1][j-1]</script></li><li>如果我们 word1[i] 与 word2 [j] 不相等，这个时候我们就必须进行调整，而调整的操作有 3 种，我们要选择一种。三种操作对应的关系试如下(注意字符串与字符的区别):<ul><li>如果把字符 word1[i] 替换成与 word2[j] 相等，则有 <script type="math/tex; mode=display">dp[i][j] = dp[i-1][j-1] + 1</script></li><li>如果在字符串word1末尾插入一个与 word2[j] 相等的字符，则有:<script type="math/tex; mode=display">dp[i][j] = dp[i] [j-1] + 1</script></li><li>如果把字符 word1[i] 删除，则有:<script type="math/tex; mode=display">dp[i][j] = dp[i-1] [j] + 1</script>那么我们应该选择一种操作，使得 dp[i] [j] 的值最小，显然有:<script type="math/tex; mode=display">dp[i][j] = min(dp[i-1][j-1]，dp[i][j-1]，dp[[i-1][j]]) + 1</script></li></ul></li></ol></li><li>找出初始值<br>我们的初始值是计算出所有的 dp[0] [0…n] 和所有的 dp[0…m][0]。这个还是非常容易计算的，因为当有一个字符串的长度为 0 时，转化为另外一个字符串，那就只能一直进行插入或者删除操作了。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">        len_word2 = len(word2)</span><br><span class="line">        len_word1 = len(word1)</span><br><span class="line">            </span><br><span class="line">        dp = [[<span class="number">0</span>] * (len_word2+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(len_word1+<span class="number">1</span>)]</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,len_word2+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>]+<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len_word1+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(word1)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,len(word2)+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>]:</span><br><span class="line">                     dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = min([dp[i<span class="number">-1</span>][j<span class="number">-1</span>],dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j]]) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><blockquote><p>reference from  <a href="https://zhuanlan.zhihu.com/p/91582909" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/91582909</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      DP understanding and practices
    
    </summary>
    
    
      <category term="Data Structure and Algorithm" scheme="https://zhangruochi.com/categories/Data-Structure-and-Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>熵与互信息</title>
    <link href="https://zhangruochi.com/%E7%86%B5%E4%B8%8E%E4%BA%92%E4%BF%A1%E6%81%AF/2019/11/12/"/>
    <id>https://zhangruochi.com/%E7%86%B5%E4%B8%8E%E4%BA%92%E4%BF%A1%E6%81%AF/2019/11/12/</id>
    <published>2019-11-12T23:34:56.000Z</published>
    <updated>2019-11-13T00:35:11.690Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信息量"><a href="#信息量" class="headerlink" title="信息量"></a>信息量</h2><p>如果有人告诉我们一个相当不可能的时间发生了，我们收到的信息要多于我们被告知某个很可能发生的事件发生时收到的信息，如果我们知道某件事情一定会发生,那么我们就不会接收到信息。</p><p>于是，我们对于信息内容的度量将依赖于概率分布 $p(x)$ ，因此我们想要寻找一个函数 $h(x)$ ，它是概率 $p(x)$ 的单调递减函数，表达了信息的内容。 h(·) 的形式可以这样寻找: 如果我们有两个不相关的事件 $x$ 和 $y$ ,那么我们观察到两个事件同时发生时获得的信息应该等于观察到事件各自发生时获得的信息之和(采用概率分布的对数作为信息的量度的原因是其可加性)</p><script type="math/tex; mode=display">h(x, y) = h(x) + h(y)</script><p>因此，信息量的公式可以为:</p><script type="math/tex; mode=display">I(x_0)=-log(p(x_0))</script><div class="table-container"><table><thead><tr><th style="text-align:left">—</th><th style="text-align:left">—</th><th style="text-align:left">—</th><th style="text-align:left">—</th></tr></thead><tbody><tr><td style="text-align:left">序号</td><td style="text-align:left">事件</td><td style="text-align:left">概率p</td><td style="text-align:left">信息量I</td></tr><tr><td style="text-align:left">A</td><td style="text-align:left">电脑正常开机</td><td style="text-align:left">0.7</td><td style="text-align:left">-log(p(A))=0.36</td></tr><tr><td style="text-align:left">B</td><td style="text-align:left">电脑无法开机</td><td style="text-align:left">0.2</td><td style="text-align:left">-log(p(B))=1.61</td></tr><tr><td style="text-align:left">C</td><td style="text-align:left">电脑爆炸了</td><td style="text-align:left">0.1</td><td style="text-align:left">-log(p(C))=2.30</td></tr></tbody></table></div><h2 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h2><p>假设一个发送者想传输一个随机变量的值给接收者。这个过程中,他们传输的平均信息量是关于概率分布 p(x) 的期望得到。即事件的概率分布和每个事件的信息量构成了一个随机变量，这个随机变量的均值（即期望）就是这个分布产生的信息量的平均值（即<strong>熵</strong>）。</p><script type="math/tex; mode=display">H(X)=-\sum_{i=1}^n p(x_i)log(p(x_i))</script><p>熵可以理解为不确定性的量度（或者说是多样性diversity的度量）。当所有态概率相等的时候最大，这个时候系统对取什么态没有偏向性，所以混乱度最大。</p><script type="math/tex; mode=display">\begin{eqnarray}H(X)&=&-[p(A)log(p(A))+p(B)log(p(B))+p(C))log(p(C))]\\&=&0.7\times 0.36+0.2\times 1.61+0.1\times 2.30\\&=&0.804\end{eqnarray}</script><h2 id="相对熵（KL离散度）"><a href="#相对熵（KL离散度）" class="headerlink" title="相对熵（KL离散度）"></a>相对熵（KL离散度）</h2><p>相对熵又称KL散度,如果我们对于同一个随机变量 x 有两个单独的概率分布 $P(x)$ 和 $Q(x)$，我们可以使用 KL 散度（Kullback-Leibler (KL) divergence）来衡量这两个分布的差异。</p><p>直观的理解就是如果用P来描述样本，那么就非常完美。而用Q来描述样本，虽然可以大致描述，但是不是那么的完美，信息量不足，需要额外的一些“信息增量”才能达到和P一样完美的描述。如果我们的Q通过反复训练，也能完美的描述样本，那么就不再需要额外的“信息增量”，Q等价于P。</p><script type="math/tex; mode=display">D_{KL}(p||q)=\sum_{i=1}^np(x_i)log(\frac{p(x_i)}{q(x_i)})</script><h2 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h2><p>对 KL离散度变形可得：</p><script type="math/tex; mode=display">\begin{eqnarray}D_{KL}(p||q) &=& \sum_{i=1}^np(x_i)log(p(x_i))-\sum_{i=1}^np(x_i)log(q(x_i))\\&=& -H(p(x))+[-\sum_{i=1}^np(x_i)log(q(x_i))]\end{eqnarray}</script><p>等式的前一部分恰巧就是p的熵，等式的后一部分，就是交叉熵：</p><script type="math/tex; mode=display">H(p,q)=-\sum_{i=1}^np(x_i)log(q(x_i))</script><p>在机器学习中，我们需要评估label和predicts之间的差距，使用KL散度刚刚好，即$D_{KL}(y||\hat{y})$，由于KL散度中的前一部分$-H(y)$不变，故在优化过程中，只需要关注交叉熵就可以了。所以一般在机器学习中直接用用交叉熵做loss,评估模型。</p><h2 id="互信息"><a href="#互信息" class="headerlink" title="互信息"></a>互信息</h2><p><strong>互信息实际上是更广泛的相对熵的特殊情形</strong>。如果变量不是独立的,那么我们可以通过考察联合概率分布与边缘概率分布乘积之间的 Kullback-Leibler 散度来判断它们是否“接近”于相互独立。如果 $(X, Y) \sim p(x, y)$, X, Y 之间的互信息 $I(X; Y)$定义为:</p><script type="math/tex; mode=display">I(X;Y) = \sum_{x\in X}\sum_{y\in Y}p(x,y)log\frac{p(x,y)}{p(x)p(y)}</script><h2 id="点互信息PMI（Pointwise-Mutual-Information）"><a href="#点互信息PMI（Pointwise-Mutual-Information）" class="headerlink" title="点互信息PMI（Pointwise Mutual Information）"></a>点互信息PMI（Pointwise Mutual Information）</h2><p><strong>互信息其实就是对X和Y的所有可能的取值情况的点互信息PMI的加权和，点互信息只是对其中两个点进行相关性判断</strong>  </p><script type="math/tex; mode=display">PMI(x;y) = log\frac{p(x,y)}{p(x)p(y)} = log\frac{p(x|y)}{p(x)} = log\frac{p(y|x)}{p(y)}</script><blockquote><p>reference from <a href="https://blog.csdn.net/pipisorry/article/details/51695283" target="_blank" rel="noopener">https://blog.csdn.net/pipisorry/article/details/51695283</a><br>reference from <a href="https://blog.csdn.net/tsyccnh/article/details/79163834" target="_blank" rel="noopener">https://blog.csdn.net/tsyccnh/article/details/79163834</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      信息量，熵，交叉熵，KL离散度，互信息
    
    </summary>
    
    
      <category term="Artificial Intelligence" scheme="https://zhangruochi.com/categories/Artificial-Intelligence/"/>
    
      <category term="Machine Learning" scheme="https://zhangruochi.com/categories/Artificial-Intelligence/Machine-Learning/"/>
    
      <category term="Math" scheme="https://zhangruochi.com/categories/Math/"/>
    
      <category term="Information Theory" scheme="https://zhangruochi.com/categories/Math/Information-Theory/"/>
    
    
  </entry>
  
  <entry>
    <title>BFS and DFS</title>
    <link href="https://zhangruochi.com/BFS-and-DFS/2019/10/17/"/>
    <id>https://zhangruochi.com/BFS-and-DFS/2019/10/17/</id>
    <published>2019-10-17T17:38:12.000Z</published>
    <updated>2019-10-19T14:48:27.413Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>广度优先搜索（Breadth-First-Search），我们平常都把简称为 BFS。直观地讲，它其实就是一种“地毯式”层层推进的搜索策略，即先查找离起始顶点最近的，然后是次近的，依次往外搜索。理解起来并不难，所以我画了一张示意图，你可以看下。</p><p><img src="1.png" alt></p><h3 id="时空分析"><a href="#时空分析" class="headerlink" title="时空分析"></a>时空分析</h3><p>每个节点入队和出队一次, 循环总次数为0(V), 检查邻接表所有的次数为O(E), 总时间为 O(V+E)</p><h3 id="最短路径-无权最短路径"><a href="#最短路径-无权最短路径" class="headerlink" title="最短路径(无权最短路径)"></a>最短路径(无权最短路径)</h3><ul><li>距离定义：从 s 到 v 经过的最少的边, 记为 d(s,v), 不可达 d(s,v) -&gt; +inf</li><li>引理:<script type="math/tex; mode=display">\forall(u,v) \in E, \ d(s,v) \leq d(s,u) + 1</script></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BFS</span><span class="params">(graph, s, t)</span>:</span></span><br><span class="line">    visited = [<span class="keyword">None</span>] * len(graph)</span><br><span class="line">    prev = [<span class="number">-1</span>] * len(graph)</span><br><span class="line">    queue = deque()</span><br><span class="line"></span><br><span class="line">    queue.append(s)</span><br><span class="line">    visited[s] = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        s = queue.popleft()</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> graph[s]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> visited[node]:</span><br><span class="line">                prev[node] = s</span><br><span class="line">                <span class="keyword">if</span> node == t:</span><br><span class="line">                    <span class="keyword">return</span> prev</span><br><span class="line">                visited[node] = <span class="keyword">True</span></span><br><span class="line">                queue.append(node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_path</span><span class="params">(prev,s,t)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> prev[t] != <span class="number">-1</span> <span class="keyword">and</span> s != t:</span><br><span class="line">        print_path(prev,s, prev[t])</span><br><span class="line">    print(str(t), end = <span class="string">" "</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    g = &#123;<span class="number">0</span>:[<span class="number">1</span>,<span class="number">3</span>],<span class="number">1</span>:[<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>],<span class="number">2</span>:[<span class="number">1</span>,<span class="number">5</span>],<span class="number">3</span>:[<span class="number">0</span>,<span class="number">4</span>],<span class="number">4</span>:[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>],<span class="number">5</span>:[<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>],<span class="number">6</span>:[<span class="number">4</span>,<span class="number">7</span>],<span class="number">7</span>:[<span class="number">5</span>,<span class="number">6</span>]&#125;</span><br><span class="line">    prev = BFS(g,<span class="number">0</span>,<span class="number">7</span>)</span><br><span class="line">    print_path(prev,<span class="number">0</span>,<span class="number">7</span>)</span><br></pre></td></tr></table></figure><ol><li><p>visited是用来记录已经被访问的顶点，用来避免顶点被重复访问。如果顶点 q 被访问，那相应的 visited[q] 会被设置为 true。</p></li><li><p>queue是一个队列，用来存储已经被访问、但相连的顶点还没有被访问的顶点。因为广度优先搜索是逐层访问的，也就是说，我们只有把第 k 层的顶点都访问完成之后，才能访问第 k+1 层的顶点。当我们访问到第 k 层的顶点的时候，我们需要把第 k 层的顶点记录下来，稍后才能通过第 k 层的顶点来找第 k+1 层的顶点。所以，我们用这个队列来实现记录的功能。</p></li><li><p>prev用来记录搜索路径。当我们从顶点 s 开始，广度优先搜索到顶点 t 后，prev 数组中存储的就是搜索的路径。不过，这个路径是反向存储的。prev[w] 存储的是，顶点 w 是从哪个前驱顶点遍历过来的。比如，我们通过顶点 2 的邻接表访问到顶点 3，那 prev[3] 就等于 2。为了正向打印出路径，我们需要递归地来打印，你可以看下 print() 函数的实现方式。</p></li></ol><p><img src="2.png" alt><br><img src="3.png" alt></p><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>深度优先搜索（Depth-First-Search），简称 DFS。最直观的例子就是“走迷宫”。</p><p>假设你站在迷宫的某个岔路口，然后想找到出口。你随意选择一个岔路口来走，走着走着发现走不通的时候，你就回退到上一个岔路口，重新选择一条路继续走，直到最终找到出口。这种走法就是一种深度优先搜索策略。</p><p>实际上，深度优先搜索用的是一种比较著名的算法思想，回溯思想。这种思想解决问题的过程，非常适合用递归来实现。</p><h3 id="时空分析-1"><a href="#时空分析-1" class="headerlink" title="时空分析"></a>时空分析</h3><p>深度优先搜索算法的消耗内存主要是 visited、prev 数组和递归调用栈。visited、prev 数组的大小跟顶点的个数 V 成正比，递归调用栈的最大深度不会超过顶点的个数，所以总的<strong>空间复杂度就是 O(V)</strong>。</p><p>深度优先搜索算法的时间复杂度是 O(E)，E 表示边的个数。</p><p><img src="4.png" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_path</span><span class="params">(prev,s,t)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> prev[t] != <span class="number">-1</span> <span class="keyword">and</span> s != t:</span><br><span class="line">        print_path(prev,s, prev[t])</span><br><span class="line">    print(str(t), end = <span class="string">" "</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DFS</span><span class="params">(graph,s,t)</span>:</span></span><br><span class="line">    visited = [<span class="keyword">None</span>] * len(graph)</span><br><span class="line">    prev = [<span class="number">-1</span>] * len(graph)</span><br><span class="line">    visited[s] = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    res,flag = <span class="keyword">None</span>, <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recur_dfs</span><span class="params">(graph,s,t, prev, visited)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> res, flag</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> s == t:</span><br><span class="line">            flag = <span class="keyword">True</span></span><br><span class="line">            res = copy.copy(prev)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> graph[s]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> visited[node]:</span><br><span class="line">                prev[node] = s</span><br><span class="line">                visited[node] = <span class="keyword">True</span></span><br><span class="line">                recur_dfs(graph,node,t,prev,visited)</span><br><span class="line">                prev[node] = <span class="number">-1</span></span><br><span class="line">                visited[node] = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    recur_dfs(graph,s,t, prev, visited)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    g = &#123;<span class="number">0</span>:[<span class="number">1</span>,<span class="number">3</span>],<span class="number">1</span>:[<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>],<span class="number">2</span>:[<span class="number">1</span>,<span class="number">5</span>],<span class="number">3</span>:[<span class="number">0</span>,<span class="number">4</span>],<span class="number">4</span>:[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>],<span class="number">5</span>:[<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>],<span class="number">6</span>:[<span class="number">4</span>,<span class="number">7</span>],<span class="number">7</span>:[<span class="number">5</span>,<span class="number">6</span>]&#125;</span><br><span class="line">    res = DFS(g,<span class="number">0</span>,<span class="number">7</span>)</span><br><span class="line">    print_path(res,<span class="number">0</span>,<span class="number">7</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      the concepts of BFS and DFS
    
    </summary>
    
    
      <category term="Data Structure and Algorithm" scheme="https://zhangruochi.com/categories/Data-Structure-and-Algorithm/"/>
    
    
  </entry>
  
</feed>
